<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>Reflective Shadow Maps</title>
  </head>
  <body style="margin-left:20%; margin-right:20%; padding:0">
    <div style = "text-align:center;">
      <canvas width="1024" height="768"></canvas>
      <p>
      <input type="checkbox" id="animateCheckbox">
      <label for="animateCheckbox">Animate</label>
      </p>
    </div>
    <div style = "text-align:left;">
      <p>
        Blabla
      </p>
    </div>
    <script type="x-shader/wgsl" id="shaders">
      struct Uniforms {
        modelMat : mat4x4<f32>,
        viewMat : mat4x4<f32>,
        projMat : mat4x4<f32>,
        lightMVP : mat4x4<f32>,
        lightPosition : vec3<f32>,
        _pad0 : f32,
        lightColor : vec3<f32>,
        _pad1 : f32,
      };
      
      @group(0) @binding(0)
      var<uniform> uniforms : Uniforms;

      @group(0) @binding(1)
      var shadowDepthTexture : texture_depth_2d;
        
      @group(0) @binding(2)
      var shadowSampler : sampler_comparison;
      
      struct RasterVertexInput {
        @location(0) pos: vec3f,
        @location(1) normal: vec3f,
        @location(2) color: vec3f,
        @location(3) uv: vec2f,
        @builtin(instance_index) instance: u32
      };
  
      struct RasterVertexOutput {
        @builtin(position) builtInPos : vec4f,
        @location(0) position: vec3f,
        @location(1) normal: vec3f,
        @location(2) color: vec3f,
        @location(3) uv: vec2f,
        @location(4) shadowPos: vec3f,
      };

      fn ambientShade(baseColor: vec3f) -> vec3f {
        const ka = 0.1;
        var fa = vec3f (1.0, 1.0, 1.0);
        return ka * fa * baseColor;
      }
      
      fn lightShade(position: vec3f, normal: vec3f, baseColor: vec3f) -> vec3f {
        var wi = normalize (uniforms.lightPosition - position);
        var li = uniforms.lightColor;
        const kd = 0.9;
        var fd = li * max (0.0, dot (wi, normal));
        var colorResponse = kd * fd * baseColor;
        return colorResponse;
      }

      fn shade(position: vec3f, normal: vec3f, baseColor: vec3f) -> vec3f {
        var colorResponse = vec3f (0.0, 0.0, 0.0);
        colorResponse += ambientShade(baseColor);
        colorResponse += lightShade(position, normal, baseColor);
        return colorResponse;
      }


      //-----------------------------------------------------------------------
      // Rasterization shaders 
      //-----------------------------------------------------------------------
      
      @vertex
        fn rasterVertexMain(input: RasterVertexInput) -> RasterVertexOutput {
          var output: RasterVertexOutput;
          output.builtInPos = uniforms.projMat * uniforms.viewMat * uniforms.modelMat * vec4f (input.pos, 1);
          output.position = input.pos;
          output.normal = input.normal;
          output.color = input.color;
          output.uv = input.uv;
          output.shadowPos = (uniforms.lightMVP * uniforms.modelMat * vec4f (input.pos, 1)).xyz;
          return output;
        }

      @fragment
        fn rasterFragmentMain(input: RasterVertexOutput) -> @location(0) vec4f {
          var projCoords = input.shadowPos / input.shadowPos.z;
          projCoords = projCoords * 0.5 + vec3f(0.5);
          var position = input.position;
          var normal = normalize (input.normal);
          var baseColor = input.color;
          var shadow = textureSampleCompare (shadowDepthTexture, shadowSampler, projCoords.xy, projCoords.z - 0.005);
          var colorResponse = ambientShade(baseColor) + shadow * lightShade(position, normal, baseColor);
          return vec4f (colorResponse, 1.0);
        }
    </script>
    <script type="x-shader/wgsl" id="shadow-shaders">
      struct Uniforms {
        lightMVP : mat4x4<f32>,
        modelMat : mat4x4<f32>
      };

      @group(0) @binding(0)
      var<uniform> uniforms : Uniforms;
      
      struct ShadowVertexInput {
        @location(0) pos: vec3f,
      };

      struct ShadowVertexOutput {
        @builtin(position) builtInPos : vec4f,
      };

      @vertex
        fn shadowVertexMain(input: ShadowVertexInput) -> ShadowVertexOutput {
          var output: ShadowVertexOutput;
          output.builtInPos = uniforms.lightMVP * uniforms.modelMat * vec4f (input.pos, 1);
          return output;
        }
    </script>
    <script type="module">

      // Minimal 4x4 Matrix implementaton, to be used for the Model-View-Projection matrix

      function mat4Identity() {
        return new Float32Array([
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          0, 0, 0, 1,
        ]);
      }
      
      function mat4Translate(x, y, z) {
        const m = mat4Identity();
        m[12] = x;
        m[13] = y;
        m[14] = z;
        return m;
      }
      
      function mat4Multiply(a, b) {
        const out = new Float32Array(16);
        for (let col = 0; col < 4; col++) {
          for (let row = 0; row < 4; row++) {
            out[col * 4 + row] =
              a[0 * 4 + row] * b[col * 4 + 0] +
              a[1 * 4 + row] * b[col * 4 + 1] +
              a[2 * 4 + row] * b[col * 4 + 2] +
              a[3 * 4 + row] * b[col * 4 + 3];
          }
        }
        return out;
      }

      function mat4Invert(a) {
        const out = new Float32Array(16);

        const a00 = a[0],  a01 = a[1],  a02 = a[2],  a03 = a[3];
        const a10 = a[4],  a11 = a[5],  a12 = a[6],  a13 = a[7];
        const a20 = a[8],  a21 = a[9],  a22 = a[10], a23 = a[11];
        const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        const b00 = a00 * a11 - a01 * a10;
        const b01 = a00 * a12 - a02 * a10;
        const b02 = a00 * a13 - a03 * a10;
        const b03 = a01 * a12 - a02 * a11;
        const b04 = a01 * a13 - a03 * a11;
        const b05 = a02 * a13 - a03 * a12;
        const b06 = a20 * a31 - a21 * a30;
        const b07 = a20 * a32 - a22 * a30;
        const b08 = a20 * a33 - a23 * a30;
        const b09 = a21 * a32 - a22 * a31;
        const b10 = a21 * a33 - a23 * a31;
        const b11 = a22 * a33 - a23 * a32;

        // Determinant
        let det =
          b00 * b11 -
          b01 * b10 +
          b02 * b09 +
          b03 * b08 -
          b04 * b07 +
          b05 * b06;

        if (!det) return null;
        det = 1.0 / det;

        out[0]  = ( a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1]  = (-a01 * b11 + a02 * b10 - a03 * b09) * det;
        out[2]  = ( a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[3]  = (-a21 * b05 + a22 * b04 - a23 * b03) * det;

        out[4]  = (-a10 * b11 + a12 * b08 - a13 * b07) * det;
        out[5]  = ( a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[6]  = (-a30 * b05 + a32 * b02 - a33 * b01) * det;
        out[7]  = ( a20 * b05 - a22 * b02 + a23 * b01) * det;

        out[8]  = ( a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[9]  = (-a00 * b10 + a01 * b08 - a03 * b06) * det;
        out[10] = ( a30 * b04 - a31 * b02 + a33 * b00) * det;
        out[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * det;

        out[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * det;
        out[13] = ( a00 * b09 - a01 * b07 + a02 * b06) * det;
        out[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * det;
        out[15] = ( a20 * b03 - a21 * b01 + a22 * b00) * det;

        return out;
      }

      function mat4Perspective(fovy, aspect, near, far) {
        const f = 1.0 / Math.tan(fovy * 0.5);
        const nf = 1.0 / (near - far);
      
        return new Float32Array([
          f / aspect, 0, 0, 0,
          0, f, 0, 0,
          0, 0, far * nf, -1,
          0, 0, (near * far) * nf, 0,
        ]);
      }

      //-----------------------------------------------------------------------
      // Primitives
      //-----------------------------------------------------------------------

      function createBox(width, height, length) {
        const w = width/2.0;
        const h = height/2.0;
        const l = length/2.0;
        const positions = [
          -w, -h,  l,
           w, -h,  l,
           w,  h,  l,
          -w,  h,  l,
          -w, -h, -l,
           w, -h, -l,
           w,  h, -l,
          -w,  h, -l,
        ];
        const den = Math.sqrt (w*w + h*h + l*l);
        const wn = w/den;
        const hn = h/den;
        const ln = l/den;
        const normals = [
          -wn, -hn,  ln,
           wn, -hn,  ln,
           wn,  hn,  ln,
          -wn,  hn,  ln,
          -wn, -hn, -ln,
           wn, -hn, -ln,
           wn,  hn, -ln,
          -wn,  hn, -ln,
        ];
        const uvs = [
          0.375, 0.750, 
          0.625, 0.750, 
          0.625, 1.0, 
          0.375, 1.0, 
          0.375, 0.250, 
          0.625, 0.250,  
          0.625, 0.5, 
          0.375, 0.5, 
        ];
        const indices = [
          0, 1, 2,
          0, 2, 3,
          1, 5, 6,
          1, 6, 2,
          5, 4, 7,
          5, 7, 6,
          4, 0, 3,
          4, 3, 7,
          3, 2, 6,
          3, 6, 7,
          4, 5, 1,
          4, 1, 0,
        ];
        const mesh = {
          positions: new Float32Array(positions),
          normals: new Float32Array(normals),
          uvs: new Float32Array(uvs),
          indices:
            positions.length / 3 > 65535
              ? new Uint32Array(indices)
              : new Uint16Array(indices)
        };
        return mesh;
      }

      function createCube(size) {
        return createBox(size, size, size);
      }

      function createSphere(radius, latitudeRes, longitudeRes) {
        const positions = [];
        const normals = [];
        const uvs = [];
        const indices = [];
      
        for (let lat = 0; lat <= latitudeRes; lat++) {
          const theta = lat * Math.PI / latitudeRes;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
      
          for (let lon = 0; lon <= longitudeRes; lon++) {
            const phi = lon * 2 * Math.PI / longitudeRes;
            const sinPhi = Math.sin(phi);
            const cosPhi = Math.cos(phi);
      
            const x = cosPhi * sinTheta;
            const y = cosTheta;
            const z = sinPhi * sinTheta;
      
            positions.push(radius * x, radius * y, radius * z);
            normals.push(x, y, z);
            uvs.push(lon / longitudeRes, 1 - lat / latitudeRes);
          }
        }
      
        for (let lat = 0; lat < latitudeRes; lat++) {
          for (let lon = 0; lon < longitudeRes; lon++) {
            const first = lat * (longitudeRes + 1) + lon;
            const second = first + longitudeRes + 1;
      
            indices.push(
              first, second, first + 1,
              second, second + 1, first + 1
            );
          }
        }
      
        const mesh = {
          positions: new Float32Array(positions),
          normals: new Float32Array(normals),
          uvs: new Float32Array(uvs),
          indices:
            positions.length / 3 > 65535
              ? new Uint32Array(indices)
              : new Uint16Array(indices)
        };
        return mesh;
      }

      function vec3Length(x) {
        return Math.sqrt (x[0]*x[0] + x[1]*x[1] + x[2]*x[2]);
      }

      function vec3Cross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }

      function vec3Normalize (x) {
        const l = vec3Length (x);
        return [x[0]/l, x[1]/l, x[2]/l];
      }

      // Assumes the normal array exists at the right size
      function computeNormals(mesh) {
        const numOfTri = mesh.indices.length/3;
        const length = mesh.normals.length;
        for (let i = 0; i < length; ++i) {
          mesh.normals[i] = 0.0;
        }
        for (let i = 0; i < numOfTri; ++i) {
          const v0 = mesh.indices[3*i];
          const v1 = mesh.indices[3*i+1];
          const v2 = mesh.indices[3*i+2];
          const p0 = [mesh.positions[3*v0], mesh.positions[3*v0+1], mesh.positions[3*v0+2]]; 
          const p1 = [mesh.positions[3*v1], mesh.positions[3*v1+1], mesh.positions[3*v1+2]]; 
          const p2 = [mesh.positions[3*v2], mesh.positions[3*v2+1], mesh.positions[3*v2+2]];
          const e01 = [p1[0]-p0[0], p1[1]-p0[1], p1[2]-p0[2]]; 
          const e12 = [p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]];
          const c = vec3Cross (e01, e12);
          const l = vec3Length(c);
          const nt = [c[0]/l, c[1]/l, c[2]/l];
          mesh.normals[3*v0] += nt[0]; 
          mesh.normals[3*v0+1] += nt[1]; 
          mesh.normals[3*v0+2] += nt[2]; 
          mesh.normals[3*v1] += nt[0]; 
          mesh.normals[3*v1+1] += nt[1]; 
          mesh.normals[3*v1+2] += nt[2]; 
          mesh.normals[3*v2 ] += nt[0]; 
          mesh.normals[3*v2 +1] += nt[1]; 
          mesh.normals[3*v2 +2] += nt[2]; 
        }
        for (let i = 0; i < length/3; ++i) {
          const ni = [mesh.normals[3*i], mesh.normals[3*i+1], mesh.normals[3*i+2]];
          const nni = vec3Normalize (ni);
          mesh.normals[3*i] = nni[0]; 
          mesh.normals[3*i+1] = nni[1]; 
          mesh.normals[3*i+2] = nni[2]; 
        }
      }

      function createCornellBox() {
        const positions = [
          // White floor
          552.8, 0.0,   0.0,   
            0.0, 0.0,   0.0,
            0.0, 0.0, 559.2,
          549.6, 0.0, 559.2,
          // White Ceiling
          556.0, 548.8, 0.0,   
          556.0, 548.8, 559.2,
            0.0, 548.8, 559.2,
            0.0, 548.8,   0.0,
          // Back white wall
          549.6,   0.0, 559.2, 
            0.0,   0.0, 559.2,
            0.0, 548.8, 559.2,
          556.0, 548.8, 559.2,
          // Right green wall
          0.0,   0.0, 559.2,   
          0.0,   0.0,   0.0,
          0.0, 548.8,   0.0,
          0.0, 548.8, 559.2,
          // Left red wall
          552.8,   0.0,   0.0, 
          549.6,   0.0, 559.2,
          556.0, 548.8, 559.2,
          556.0, 548.8,   0.0,
          // Short white block
          130.0, 165.0,  65.0, 
           82.0, 165.0, 225.0,
          240.0, 165.0, 272.0,
          290.0, 165.0, 114.0,

          290.0,   0.0, 114.0,
          290.0, 165.0, 114.0,
          240.0, 165.0, 272.0,
          240.0,   0.0, 272.0,

          130.0,   0.0,  65.0,
          130.0, 165.0,  65.0,
          290.0, 165.0, 114.0,
          290.0,   0.0, 114.0,

           82.0,   0.0, 225.0,
           82.0, 165.0, 225.0,
          130.0, 165.0,  65.0,
          130.0,   0.0,  65.0,

          240.0,   0.0, 272.0,
          240.0, 165.0, 272.0,
           82.0, 165.0, 225.0,
           82.0,   0.0, 225.0,

           // Tall white block
           423.0, 330.0, 247.0,
           265.0, 330.0, 296.0,
           314.0, 330.0, 456.0,
           472.0, 330.0, 406.0,

           423.0,   0.0, 247.0,
           423.0, 330.0, 247.0,
           472.0, 330.0, 406.0,
           472.0,   0.0, 406.0,

           472.0,   0.0, 406.0,
           472.0, 330.0, 406.0,
           314.0, 330.0, 456.0,
           314.0,   0.0, 456.0,

           314.0,   0.0, 456.0,
           314.0, 330.0, 456.0,
           265.0, 330.0, 296.0,
           265.0,   0.0, 296.0,

           265.0,   0.0, 296.0,
           265.0, 330.0, 296.0,
           423.0, 330.0, 247.0,
           423.0,   0.0, 247.0,
        ];
        const normals = [
          // White floor
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          // White Ceiling
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          // Back white wall
          0, 0, -1, 
          0, 0, -1, 
          0, 0, -1, 
          0, 0, -1,
          // Right green wall
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0,  
          // Left red wall
          -1, 0, 0, 
          -1, 0, 0, 
          -1, 0, 0, 
          -1, 0, 0,
          // Short whie block
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          // Tall whie block
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,  
        ];
        const colors = [
          // White floor
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          // White Ceiling
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          // Back white wall
          1, 1, 1, 
          1, 1, 1, 
          1, 1, 1, 
          1, 1, 1,
          // Right green wall
          0, 1, 0, 
          0, 1, 0, 
          0, 1, 0, 
          0, 1, 0, 
          // Left red wall
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0, 
          // Short whie block 
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          // Tall whie block 
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
        ];
        const uvs = [
          // White floor
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,
          // White Ceiling
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Back white wall
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Right green wall
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Left red wall
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,
          // Short white block
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Tall white block
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,
        ];
        const indices = [
          // White floor
          0, 1, 2,
          0, 2, 3,
          // White Ceiling
          4, 5, 6,
          4, 6, 7,
          // Back white wall
          8, 9, 10,
          8, 10,11,
          // Right green wall
          12, 13, 14,
          12, 14, 15,
          // Left red wall
          16, 17, 18,
          16, 18, 19,
          // Short white block
          20, 21, 22,
          20, 22, 23,

          24, 25, 26,
          24, 26, 27,

          28, 29, 30,
          28, 30, 31,

          32, 33, 34,
          32, 34, 35,

          36, 37, 38, 
          36, 38, 39,
          // Tall white block
          40, 41, 42,
          40, 42, 43,

          44, 45, 46,
          44, 46, 47,

          48, 49, 50, 
          48, 50, 51,

          52, 53, 54,
          52, 54, 55,

          56, 57, 58,
          56, 58, 59,
        ];
        const mesh = {
          positions: new Float32Array(positions),
          normals: new Float32Array(normals),
          colors: new Float32Array(colors),
          uvs: new Float32Array(uvs),
          indices: new Uint32Array(indices)
        };
        computeNormals (mesh);
        return mesh;
      }

      //-----------------------------------------------------------------------
      // Camera
      //-----------------------------------------------------------------------

      function getCameraPosition(camera) {
        return [
          camera.target[0] + camera.radius * Math.cos(camera.pitch) * Math.sin(camera.yaw),
          camera.target[1] + camera.radius * Math.sin(camera.pitch),
          camera.target[2] + camera.radius * Math.cos(camera.pitch) * Math.cos(camera.yaw)
        ];
      }

      function pan(camera, dx, dy) {
        const cosYaw = Math.cos(camera.yaw);
        const sinYaw = Math.sin(camera.yaw);

        // right vector
        const rightX = cosYaw;
        const rightZ = -sinYaw;

        // up vector (world up)
        const upX = 0;
        const upY = 1;
        const upZ = 0;

        const scale = camera.radius * camera.panSpeed;

        camera.target[0] -= (rightX * dx - upX * dy) * scale;
        camera.target[1] -= dy * scale;
        camera.target[2] -= (rightZ * dx - upZ * dy) * scale;
      }

      function lookAt(out, eye, target, up) {
        let zx = eye[0] - target[0];
        let zy = eye[1] - target[1];
        let zz = eye[2] - target[2];

        let len = Math.hypot(zx, zy, zz);
        zx /= len; zy /= len; zz /= len;

        let xx = up[1] * zz - up[2] * zy;
        let xy = up[2] * zx - up[0] * zz;
        let xz = up[0] * zy - up[1] * zx;

        len = Math.hypot(xx, xy, xz);
        xx /= len; xy /= len; xz /= len;

        const yx = zy * xz - zz * xy;
        const yy = zz * xx - zx * xz;
        const yz = zx * xy - zy * xx;

        out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
        out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
        out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
        out[12] = -(xx * eye[0] + xy * eye[1] + xz * eye[2]);
        out[13] = -(yx * eye[0] + yy * eye[1] + yz * eye[2]);
        out[14] = -(zx * eye[0] + zy * eye[1] + zz * eye[2]);
        out[15] = 1;
      }

      function updateCamera(camera) {
        const eye = getCameraPosition(camera);
        lookAt(camera.viewMat, eye, camera.target, camera.up);
      }

      function createCamera (aspect) {
        const camera = {};
        camera.modelMat = mat4Identity(0, 0, 0);
        camera.viewMat  = mat4Identity(); 
        // Intrinsic parameters
        camera.fov = Math.PI / 4.0;
        camera.aspect = aspect;
        camera.near = 0.1;
        camera.far = 10000.0;
        camera.projMat  = mat4Perspective(
          camera.fov,
          camera.aspect,
          camera.near,
          camera.far
        );
        camera.yaw = Math.PI;
        camera.pitch = 0;
        camera.radius = 1000;
        
        camera.target = [280, 280, 280];
        camera.up = [0, 1, 0];
        
        camera.rotateSpeed = 0.005;
        camera.zoomSpeed = 0.001;
        camera.panSpeed = 0.002;
        
        camera.minRadius = 1;
        camera.maxRadius = 10000;
  
        camera.dragging = false;
        camera.panning = false;
        camera.lastX = 0;
        camera.lastY = 0;
        return camera;
      }

      //-----------------------------------------------------------------------
      // Scene
      //-----------------------------------------------------------------------

      function createScene(camAspect) {
        const scene = {
          camera: createCamera(camAspect),
          lightSource: {
            position: [280.0, 140.0, -280.0],
            color: [1.0, 1.0, 1.0],
            lightViewMat: mat4Identity(),
            lightProjMat: mat4Perspective(
              Math.PI / 4.0,
              1.0,
              0.1,
              10000.0
            ),
          },
          //mesh: createCube(1.2),
          //mesh: createSphere(0.8, 32, 32),
          mesh: createCornellBox(),
          time: 0,
        };
        lookAt(scene.lightSource.lightViewMat, scene.lightSource.position, [280.0, 280.0, 280.0], [0, 1, 0]);
        return scene;
      }

      async function createGPUApp() {
        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }
        const GPUApp = {
          // Components used for setting up the graphics environment
          canvas: {},
          // Implementation of WebGPU
          adapter: {},
          // GPU interface to create objects on the GPU
          device: {},
          // Configures WebGPU
          context: {},
          canvasFormat: {},
          // GPU memory story the mesh data
          meshBuffers:{},
          // GPU memory used to pass parameters from CPU to GPU, such as the camera or light properties
          uniformBuffer: {},
          uniformBufferForShadow: {},
          // Handle on GPU parameters
          bindGroup: {},
          bindGroupForShadow: {},
          // Handle on the GPU shaders
          shaderModule: {},
          // Shadow code used for rendering
          shadowShaderModule: {},
          // Organization of the input of the pipeline/vertex shader
          vertexBuffersLayout: {},
          vertexBuffersLayoutForShadow: {},
          // Organization of the 
          bindGroupLayout: {},
          bindGroupLayoutForShadow: {},
          // Rasterization pipeline
          rasterizationPipeline: {},
          // Shadow pipeline
          shadowPipeline: {},
          // Depth map used to store per-pixel depth (Z-Buffer)
          depthTexture: {},
          // Shadow depth map
          shadowDepthTexture: {},
          shadowDepthTextureView: {},
          // Model/View/Inverse View/Projection matrix (16 floats each), light position (3+1 pad floats), color (3+1 pad float), fov  (1+3 pad float), aspectRatio (1+3 pad fsloat)
          uniformData : new Float32Array(72),
          uniformDataForShadow : new Float32Array(16+16),
        };
        GPUApp.canvas = document.querySelector("canvas"),
        GPUApp.adapter = await navigator.gpu.requestAdapter();
        if (!GPUApp.adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }
        GPUApp.device = await GPUApp.adapter.requestDevice();
        GPUApp.context = GPUApp.canvas.getContext("webgpu");
        GPUApp.canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        GPUApp.context.configure({
          device: GPUApp.device,
          format: GPUApp.canvasFormat,
          alphaMode: "opaque",
        });
        return GPUApp;
      }

      function createGPUBuffer(device, data, usage) {
        const buffer = device.createBuffer({
          size: (data.byteLength + 3) & ~3, // 4-byte aligned
          usage
        });
        device.queue.writeBuffer(buffer, 0, data);
      
        return buffer;
      }

      function createMeshBuffers(GPUApp, mesh) {
        return {
          positionBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.positions,
            GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),
          
          normalBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.normals,
            GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),

          colorBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.colors,
            GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),
          
          uvBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.uvs,
            GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
          ),
          
          indexBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.indices,
            GPUBufferUsage.INDEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),
          
          indexFormat: "uint32"
        };
      }

      function createVertexBuffersLayoutForShadow() {
        return [
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" } // position
            ]
          }
        ];
      }
      
      function createVertexBuffersLayout() {
        return [
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" } // position
            ]
          },
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 1, offset: 0, format: "float32x3" } // normal
            ]
          },
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 2, offset: 0, format: "float32x3" } // color
            ]
          },
          {
            arrayStride: 2 * 4,
            attributes: [
              { shaderLocation: 3, offset: 0, format: "float32x2" } // uv
            ]
          }
        ];
      }

      // Create and fill the GPU buffers used to store the geometry to render
      function initGPUBuffers(GPUApp, scene) {

        GPUApp.meshBuffers = createMeshBuffers(GPUApp, scene.mesh);

        GPUApp.uniformBuffer = createGPUBuffer(
          GPUApp.device, 
          GPUApp.uniformData, 
          GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        );

        GPUApp.uniformBufferForShadow = createGPUBuffer(
          GPUApp.device, 
          GPUApp.uniformDataForShadow, 
          GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        );

        GPUApp.bindGroupForShadow = GPUApp.device.createBindGroup({
          layout: GPUApp.bindGroupLayoutForShadow,
          entries: [{
            binding: 0,
            resource: { buffer: GPUApp.uniformBufferForShadow },
          }],
         });

        GPUApp.bindGroup = GPUApp.device.createBindGroup({
          layout: GPUApp.bindGroupLayout,
          entries: [{
            binding: 0,
            resource: { buffer: GPUApp.uniformBuffer },
          },
          {
            binding: 1,
            resource: GPUApp.shadowDepthTextureView,
          },
          {
            binding: 2,
            resource: GPUApp.device.createSampler({
              compare: "less",
              magFilter: "linear",
              minFilter: "linear",
              mipmapFilter: "linear",
            }),
          }],
         });
      }

      function initRenderPipeline(GPUApp) {
        const shaders = document.getElementById("shaders").textContent;
        const shadowShaders = document.getElementById("shadow-shaders").textContent;
        GPUApp.shaderModule = GPUApp.device.createShaderModule({
          label: "Shaders",
          code: shaders
        });
        GPUApp.shadowShaderModule = GPUApp.device.createShaderModule({
          label: "Shadow Shaders",
          code: shadowShaders
        });

        GPUApp.vertexBuffersLayoutForShadow = createVertexBuffersLayoutForShadow();
        GPUApp.vertexBuffersLayout = createVertexBuffersLayout();

        GPUApp.bindGroupLayoutForShadow = GPUApp.device.createBindGroupLayout({
          entries: [{
            binding: 0,
            visibility: GPUShaderStage.VERTEX,
            buffer: { type: "uniform" },
          }],
        });

        GPUApp.bindGroupLayout = GPUApp.device.createBindGroupLayout({
          entries: [{
            binding: 0,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "uniform" },
          },
          {
            binding: 1,
            visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
            texture: { sampleType: "depth" },
          },
          {
            binding: 2,
            visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
            sampler: { type: "comparison" },
          }],
        });  

        GPUApp.rasterizationPipeline = GPUApp.device.createRenderPipeline({
            label: "rasterizationPipeline",
            //layout: "auto",
            layout: GPUApp.device.createPipelineLayout({
              bindGroupLayouts: [GPUApp.bindGroupLayout],
            }),
            vertex: {
              module: GPUApp.shaderModule,
              entryPoint: "rasterVertexMain",
              buffers: GPUApp.vertexBuffersLayout
            },
            fragment: {
              module: GPUApp.shaderModule,
              entryPoint: "rasterFragmentMain",
              targets: [{
                format: GPUApp.canvasFormat
              }]
            },
            primitive: {
              topology: "triangle-list", // use "line-list" for sanity check
              cullMode: "back", // activate backface culling
            },
            depthStencil: {
              format: "depth24plus",   // Must match depth texture
              depthWriteEnabled: true,
              depthCompare: "less",    // Standard depth (Z) test
          },
        });

        // Texture used for the Z-Buffer depth test
        GPUApp.depthTexture = GPUApp.device.createTexture({
          size: [GPUApp.canvas.width, GPUApp.canvas.height],
          format: "depth24plus",
          usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });

        // Texture used for the shadow map
        GPUApp.shadowDepthTexture = GPUApp.device.createTexture({
          size: [1024, 1024, 1],
          format: "depth32float",
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
        });
        GPUApp.shadowDepthTextureView = GPUApp.shadowDepthTexture.createView();

        GPUApp.shadowPipeline = GPUApp.device.createRenderPipeline({
            label: "shadowPipeline",
            //layout: "auto",
            layout: GPUApp.device.createPipelineLayout({
              bindGroupLayouts: [GPUApp.bindGroupLayoutForShadow],
            }),
            vertex: {
              module: GPUApp.shadowShaderModule,
              entryPoint: "shadowVertexMain",
              buffers: GPUApp.vertexBuffersLayoutForShadow
            },
            primitive: {
              topology: "triangle-list", // use "line-list" for sanity check
              cullMode: "back", // activate backface culling
            },
            depthStencil: {
              format: "depth32float",   // Must match depth texture
              depthWriteEnabled: true,
              depthCompare: "less",    // Standard depth (Z) test
          },
        });
      }

      function initEvents (GPUApp, scene) {
        GPUApp.canvas.addEventListener("mousedown", e => {
          scene.camera.lastX = e.clientX;
          scene.camera.lastY = e.clientY;

          if (e.button === 0) scene.camera.dragging = true;   // left = rotate
          if (e.button === 1 || e.button === 2) scene.camera.panning = true; // middle/right = pan
        });

        window.addEventListener("mouseup", () => {
          scene.camera.dragging = false;
          scene.camera.panning = false;
        });

        GPUApp.canvas.addEventListener("mousemove", e => {
          const dx = e.clientX - scene.camera.lastX;
          const dy = e.clientY - scene.camera.lastY;
          scene.camera.lastX = e.clientX;
          scene.camera.lastY = e.clientY;

          if (scene.camera.dragging) {
            scene.camera.yaw   -= dx * scene.camera.rotateSpeed;
            scene.camera.pitch += dy * scene.camera.rotateSpeed;

            const maxPitch = Math.PI / 2 - 0.01;
            scene.camera.pitch = Math.max(-maxPitch, Math.min(maxPitch, scene.camera.pitch));
          }

          if (scene.camera.panning) {
            pan(scene.camera, dx, -dy);
          }
        });

        GPUApp.canvas.addEventListener("wheel", e => {
          e.preventDefault();
          scene.camera.radius *= 1 + e.deltaY * scene.camera.zoomSpeed;
          scene.camera.radius = Math.max(scene.camera.minRadius, Math.min(scene.camera.maxRadius, scene.camera.radius));
        }, { passive: false });

        GPUApp.canvas.addEventListener("contextmenu", e => e.preventDefault());
      }

      function animate(scene) {
        scene.time += 1.0;
        const angle = scene.time/40.0;
        scene.lightSource.position = [200.0*Math.cos (angle) + 280, 500, 200.0*Math.sin (angle) + 280];
        lookAt(scene.lightSource.lightViewMat, scene.lightSource.position, scene.camera.target, scene.camera.up);
      }

      function updateUniforms(GPUApp, scene) {
        updateCamera(scene.camera);
        let lightMVP = mat4Multiply(scene.lightSource.lightProjMat, scene.lightSource.lightViewMat);
        GPUApp.uniformData.set(scene.camera.modelMat, 0);
        GPUApp.uniformData.set(scene.camera.viewMat, 16);
        GPUApp.uniformData.set(scene.camera.projMat, 32);
        GPUApp.uniformData.set(lightMVP, 48);
        GPUApp.uniformData.set(scene.lightSource.position, 64);
        GPUApp.uniformData[67] = 1.0; // pad
        GPUApp.uniformData.set(scene.lightSource.color, 68);
        GPUApp.uniformData[71] = 1.0; // pad
        GPUApp.device.queue.writeBuffer(
          GPUApp.uniformBuffer,
          0,
          GPUApp.uniformData.buffer,
          GPUApp.uniformData.byteOffset,
          GPUApp.uniformData.byteLength
        );
      }

      function updateUniformsForShadow(GPUApp, scene) {
        let lightMVP = mat4Multiply(scene.lightSource.lightProjMat, scene.lightSource.lightViewMat);
        GPUApp.uniformDataForShadow.set(lightMVP, 0);
        GPUApp.uniformDataForShadow.set(scene.camera.modelMat, 16);
        GPUApp.device.queue.writeBuffer(
          GPUApp.uniformBufferForShadow,
          0,
          GPUApp.uniformDataForShadow.buffer,
          GPUApp.uniformDataForShadow.byteOffset,
          GPUApp.uniformDataForShadow.byteLength
        );
      }

      function render(GPUApp, scene) {
        if (document.getElementById("animateCheckbox").checked)
          animate(scene);
        updateUniforms(GPUApp, scene);
        updateUniformsForShadow(GPUApp, scene);
        const encoder = GPUApp.device.createCommandEncoder();
        const shadowPass = encoder.beginRenderPass({
          label: "Shadow map generation pass",
          colorAttachments: [],
          depthStencilAttachment: {
            view: GPUApp.shadowDepthTextureView,
            depthClearValue: 1.0,
            depthLoadOp: "clear",
            depthStoreOp: "store",
          },
        });
        shadowPass.setPipeline(GPUApp.shadowPipeline);
        shadowPass.setBindGroup(0, GPUApp.bindGroupForShadow);
        shadowPass.setVertexBuffer(0, GPUApp.meshBuffers.positionBuffer);
        shadowPass.setIndexBuffer(GPUApp.meshBuffers.indexBuffer, GPUApp.meshBuffers.indexFormat);
        shadowPass.drawIndexed(scene.mesh.indices.length);
        shadowPass.end();

        const renderPass = encoder.beginRenderPass({
          label: "Main rendering pass",
          colorAttachments: [{
            view: GPUApp.context.getCurrentTexture().createView(),
            loadOp: "clear",
            clearValue: { r: 0, g: 0, b: 0, a: 1 },
            storeOp: "store",
          }],
          sampleCount: 1,
          depthStencilAttachment: {
            view: GPUApp.depthTexture.createView(),
            depthClearValue: 1.0,
            depthLoadOp: "clear",
            depthStoreOp: "store",
          },
        });
        renderPass.setPipeline(GPUApp.rasterizationPipeline);
        renderPass.setBindGroup(0, GPUApp.bindGroup);
        renderPass.setVertexBuffer(0, GPUApp.meshBuffers.positionBuffer);
        renderPass.setVertexBuffer(1, GPUApp.meshBuffers.normalBuffer);
        renderPass.setVertexBuffer(2, GPUApp.meshBuffers.colorBuffer);
        renderPass.setVertexBuffer(3, GPUApp.meshBuffers.uvBuffer);
        renderPass.setIndexBuffer(GPUApp.meshBuffers.indexBuffer, GPUApp.meshBuffers.indexFormat);
        renderPass.drawIndexed(scene.mesh.indices.length);
        renderPass.end();
        const commandBuffer = encoder.finish();
        GPUApp.device.queue.submit([commandBuffer]);
      }

      async function main() {
        const GPUApp = await createGPUApp();
        const camAspect = GPUApp.canvas.width/GPUApp.canvas.height;
        initRenderPipeline(GPUApp);
        const scene = createScene(camAspect);
        initEvents (GPUApp, scene);
        initGPUBuffers(GPUApp, scene);
        // Animate at 60Hz
        setInterval(function() { render(GPUApp, scene); }, 16.6);
      }

      main();

    </script>
  </body>
</html>