<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>Reflective Shadow Maps</title>
  </head>
  <body style="margin-left:20%; margin-right:20%; padding:0">
    <div style = "text-align:center;">
      <canvas width="1024" height="768"></canvas>
      <div style="text-align:center; margin-top:10px;">
        <label>Debug View:</label>
        <select id="debugSelect">
          <option value="none">None</option>
          <option value="depth">Shadow Depth</option>
          <option value="position">Shadow Position</option>
          <option value="normal">Shadow Normal</option>
          <option value="flux">Shadow Flux</option>
        </select>
        <input type="checkbox" id="animateCheckbox">
        <label for="animateCheckbox">Animate</label>
      </div>
    </div>
    <div style = "text-align:left;">
      <p>
        Blabla
      </p>
    </div>
    <script type="x-shader/wgsl" id="main-shaders">
      struct Uniforms {
        modelMat : mat4x4<f32>,
        viewMat : mat4x4<f32>,
        projMat : mat4x4<f32>,
        lightMVP : mat4x4<f32>,
        lightPosition : vec3<f32>,
        _pad0 : f32,
        lightColor : vec3<f32>,
        _pad1 : f32,
      };
      
      @group(0) @binding(0)
      var<uniform> uniforms : Uniforms;

      @group(0) @binding(1)
      var shadowDepthTexture : texture_depth_2d;
        
      @group(0) @binding(2)
      var shadowPositionTexture : texture_2d<f32>;

      @group(0) @binding(3)
      var shadowNormalTexture : texture_2d<f32>;

      @group(0) @binding(4)
      var shadowFluxTexture : texture_2d<f32>;

      @group(0) @binding(5)
      var shadowSampler : sampler_comparison;
      
      struct RasterVertexInput {
        @location(0) pos: vec3f,
        @location(1) normal: vec3f,
        @location(2) color: vec3f,
        @location(3) uv: vec2f,
        @builtin(instance_index) instance: u32
      };
  
      struct RasterVertexOutput {
        @builtin(position) builtInPos : vec4f,
        @location(0) position: vec3f,
        @location(1) normal: vec3f,
        @location(2) color: vec3f,
        @location(3) uv: vec2f,
        @location(4) shadowPos: vec4f,
      };

      const SAMPLE_COUNT = 200u;

      fn ambientShade(baseColor: vec3f) -> vec3f {
        const ka = 0.1;
        var fa = vec3f (1.0, 1.0, 1.0);
        return ka * fa * baseColor;
      }
      
      fn lightShade(position: vec3f, normal: vec3f, baseColor: vec3f) -> vec3f {
        var wi = normalize (uniforms.lightPosition - position);
        var li = uniforms.lightColor;
        const kd = 0.9;
        var fd = li * max (0.0, dot (wi, normal));
        var colorResponse = kd * fd * baseColor;
        return colorResponse;
      }

      fn shade(position: vec3f, normal: vec3f, baseColor: vec3f, shadow: f32) -> vec3f {
        var colorResponse = vec3f (0.0, 0.0, 0.0);
        colorResponse += ambientShade(baseColor);
        colorResponse += shadow * lightShade(position, normal, baseColor);
        return colorResponse;
      }

      fn worldToLightUV(worldPos: vec3<f32>) -> vec2<f32> {
        let lightClip = uniforms.lightMVP * uniforms.modelMat * vec4(worldPos, 1.0);
        let ndc = lightClip.xyz / lightClip.w;
        return ndc.xy * 0.5 + vec2(0.5);
      }
      
      fn randomDisk(i: u32) -> vec2<f32> {
        let angle = 6.2831853 * f32(i) / f32(SAMPLE_COUNT);
        let radius = sqrt(f32(i) / f32(SAMPLE_COUNT));
        return vec2(cos(angle), sin(angle)) * radius;
      }

      fn computeIndirect(P: vec3<f32>, N: vec3<f32>) -> vec3<f32> {
        var indirect = vec3<f32>(0.0);
        let baseUV = worldToLightUV(P);
        let rsmResolution = vec2<f32>(512.0, 512.0);
        let sampleRadius = 20.0 / rsmResolution.x; // tune this

        for (var i: u32 = 0u; i < SAMPLE_COUNT; i++) {
          let offset = randomDisk(i) * sampleRadius;
          let uv = baseUV + offset;

          // sample RSM
          let Pi = textureLoad(shadowPositionTexture, vec2i(uv * rsmResolution), 0).xyz;
          let Ni = textureLoad(shadowNormalTexture, vec2i(uv * rsmResolution), 0).xyz;
          let flux = textureLoad(shadowFluxTexture, vec2i(uv * rsmResolution), 0).xyz;

          let dir = Pi - P;
          let dist2 = max(dot(dir, dir), 0.001);
          let wi = normalize(dir);

          let receiverCos = max(dot(N, wi), 0.0);
          let emitterCos  = max(dot(Ni, -wi), 0.0);

          indirect += flux * receiverCos * emitterCos / dist2;
        }
        return indirect / f32(SAMPLE_COUNT);
      }

      //-----------------------------------------------------------------------
      // Rasterization shaders 
      //-----------------------------------------------------------------------
      
      @vertex
        fn rasterVertexMain(input: RasterVertexInput) -> RasterVertexOutput {
          var output: RasterVertexOutput;
          output.builtInPos = uniforms.projMat * uniforms.viewMat * uniforms.modelMat * vec4f (input.pos, 1);
          output.position = input.pos;
          output.normal = input.normal;
          output.color = input.color;
          output.uv = input.uv;
          output.shadowPos = uniforms.lightMVP * uniforms.modelMat * vec4f (input.pos, 1);
          return output;
        }

      @fragment
        fn rasterFragmentMain(input: RasterVertexOutput) -> @location(0) vec4f {
          var homogeneousCoords = input.shadowPos.xyz / input.shadowPos.w;
          var projCoords = vec3f(homogeneousCoords.x*0.5+0.5, homogeneousCoords.y*0.5+0.5, homogeneousCoords.z);
          var position = input.position;
          var normal = normalize (input.normal);
          var baseColor = input.color;
          var shadow = textureSampleCompare (shadowDepthTexture, shadowSampler, vec2f(projCoords.x, 1.0 - projCoords.y), projCoords.z - 0.00004);
          var colorResponse = shade(position, normal, baseColor, shadow);
          colorResponse += computeIndirect(position, normal);
          return vec4f (colorResponse, 1.0);
        }
    </script>
    <script type="x-shader/wgsl" id="shadow-shaders">
      struct Uniforms {
        lightMVP : mat4x4<f32>,
        modelMat : mat4x4<f32>,
        lightColor : vec3<f32>,
        _pad0 : f32,
      };

      @group(0) @binding(0)
      var<uniform> uniforms : Uniforms;
      
      struct ShadowVertexInput {
        @location(0) pos: vec3f,
        @location(1) normal: vec3f,
        @location(2) color: vec3f,
      };

      struct ShadowVertexOutput {
        @builtin(position) builtInPos : vec4f,
        @location(0) position: vec4f,
        @location(1) normal: vec4f,
        @location(2) color: vec4f,
      };

      struct ShadowFragmentOutput {
        @location(0) position: vec4f,
        @location(1) normal: vec4f,
        @location(2) flux: vec4f,
      };

      @vertex
        fn shadowVertexMain(input: ShadowVertexInput) -> ShadowVertexOutput {
          var output: ShadowVertexOutput;
          output.builtInPos = uniforms.lightMVP * uniforms.modelMat * vec4f (input.pos, 1);
          output.position = uniforms.modelMat * vec4f (input.pos, 1);
          output.normal = uniforms.modelMat * vec4f (input.normal, 1.0);
          output.color = vec4f (input.color * uniforms.lightColor, 1.0);
          return output;
        }

      @fragment
        fn shadowFragmentMain(input: ShadowVertexOutput) -> ShadowFragmentOutput {
          var output: ShadowFragmentOutput;
          output.position = input.position;
          output.normal = vec4f (normalize (input.normal.xyz), 1.0);
          output.flux = input.color;
          return output;
        }
    </script>
    <script type="x-shader/wgsl" id="debug-shaders">
      struct Uniforms {
        debugView : u32,
        _pad0 : vec3<u32>,
      };

      @group(0) @binding(0)
      var<uniform> uniforms : Uniforms;

      @group(0) @binding(1)
      var shadowDepthTexture : texture_depth_2d;
        
      @group(0) @binding(2)
      var shadowPositionTexture : texture_2d<f32>;

      @group(0) @binding(3)
      var shadowNormalTexture : texture_2d<f32>;

      @group(0) @binding(4)
      var shadowFluxTexture : texture_2d<f32>;

      struct DebugVertexOutput {
        @builtin(position) builtInPos : vec4f,
        @location(0) uv: vec2f,
      };

      @vertex
        fn debugVertexMain(@builtin(vertex_index) vertexIndex: u32) -> DebugVertexOutput {
          var pos = array<vec2f, 3>(
            vec2f(-1.0, -1.0),
            vec2f( 3.0, -1.0),
            vec2f(-1.0,  3.0)
          );

          var uv = array<vec2f, 3>(
            vec2f(0.0, 0.0),
            vec2f(2.0, 0.0),
            vec2f(0.0, 2.0)
          );
          var output: DebugVertexOutput;
          output.builtInPos = vec4f (pos[vertexIndex], 0, 1);
          output.uv = uv[vertexIndex];
          return output;
        }

      @fragment
        fn debugFragmentMain(input: DebugVertexOutput) -> @location(0) vec4f {
          var color: vec4f = vec4f (0.0, 0.0, 0.0, 1.0);
          let uvFlipped = vec2f(input.uv.x, 1.0 - input.uv.y);
          if (uniforms.debugView == 1u) {
            let depth = textureLoad (shadowDepthTexture, vec2i(uvFlipped * vec2f(textureDimensions(shadowDepthTexture))), 0);
            
            // For this one we have to convert to linear depth otherwise we can't see anything
            let near = 1.0;
            let far = 1000.0;
            let z = depth * 2.0 - 1.0;
            let linearDepth = (2.0 * near * far) / (far + near - z * (far - near));
            let normalized = linearDepth / far;

            color = vec4f(vec3f(normalized), 1.0);
          } else if (uniforms.debugView == 2u) { 
            let texture = textureLoad (shadowPositionTexture, vec2i(uvFlipped * vec2f(textureDimensions(shadowPositionTexture))), 0);
            let normalized = (texture.xyz + vec3f(500.0, 500.0, 500.0)) / vec3f(1000.0, 1000.0, 1000.0); // I need to find a better, generalized way to map to [0, 1]
            color = vec4f(normalized, 1.0);
          } else if (uniforms.debugView == 3u) {
            let texture = textureLoad (shadowNormalTexture, vec2i(uvFlipped * vec2f(textureDimensions(shadowNormalTexture))), 0);
            let normalized = 0.5 * texture.xyz + vec3f(0.5, 0.5, 0.5); // [-1, 1] -> [0, 1]
            color = vec4f(normalized, 1.0);
          } else if (uniforms.debugView == 4u) {
            color = textureLoad (shadowFluxTexture, vec2i(uvFlipped * vec2f(textureDimensions(shadowFluxTexture))), 0);
          }
          return color;
        }
    </script>
    <script type="module">

      // Minimal 4x4 Matrix implementation, to be used for the Model-View-Projection matrix

      function mat4Identity() {
        return new Float32Array([
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          0, 0, 0, 1,
        ]);
      }
      
      function mat4Translate(x, y, z) {
        const m = mat4Identity();
        m[12] = x;
        m[13] = y;
        m[14] = z;
        return m;
      }
      
      function mat4Multiply(a, b) {
        const out = new Float32Array(16);
        for (let col = 0; col < 4; col++) {
          for (let row = 0; row < 4; row++) {
            out[col * 4 + row] =
              a[0 * 4 + row] * b[col * 4 + 0] +
              a[1 * 4 + row] * b[col * 4 + 1] +
              a[2 * 4 + row] * b[col * 4 + 2] +
              a[3 * 4 + row] * b[col * 4 + 3];
          }
        }
        return out;
      }

      function mat4Invert(a) {
        const out = new Float32Array(16);

        const a00 = a[0],  a01 = a[1],  a02 = a[2],  a03 = a[3];
        const a10 = a[4],  a11 = a[5],  a12 = a[6],  a13 = a[7];
        const a20 = a[8],  a21 = a[9],  a22 = a[10], a23 = a[11];
        const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        const b00 = a00 * a11 - a01 * a10;
        const b01 = a00 * a12 - a02 * a10;
        const b02 = a00 * a13 - a03 * a10;
        const b03 = a01 * a12 - a02 * a11;
        const b04 = a01 * a13 - a03 * a11;
        const b05 = a02 * a13 - a03 * a12;
        const b06 = a20 * a31 - a21 * a30;
        const b07 = a20 * a32 - a22 * a30;
        const b08 = a20 * a33 - a23 * a30;
        const b09 = a21 * a32 - a22 * a31;
        const b10 = a21 * a33 - a23 * a31;
        const b11 = a22 * a33 - a23 * a32;

        // Determinant
        let det =
          b00 * b11 -
          b01 * b10 +
          b02 * b09 +
          b03 * b08 -
          b04 * b07 +
          b05 * b06;

        if (!det) return null;
        det = 1.0 / det;

        out[0]  = ( a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1]  = (-a01 * b11 + a02 * b10 - a03 * b09) * det;
        out[2]  = ( a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[3]  = (-a21 * b05 + a22 * b04 - a23 * b03) * det;

        out[4]  = (-a10 * b11 + a12 * b08 - a13 * b07) * det;
        out[5]  = ( a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[6]  = (-a30 * b05 + a32 * b02 - a33 * b01) * det;
        out[7]  = ( a20 * b05 - a22 * b02 + a23 * b01) * det;

        out[8]  = ( a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[9]  = (-a00 * b10 + a01 * b08 - a03 * b06) * det;
        out[10] = ( a30 * b04 - a31 * b02 + a33 * b00) * det;
        out[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * det;

        out[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * det;
        out[13] = ( a00 * b09 - a01 * b07 + a02 * b06) * det;
        out[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * det;
        out[15] = ( a20 * b03 - a21 * b01 + a22 * b00) * det;

        return out;
      }

      function mat4Perspective(fovy, aspect, near, far) {
        const f = 1.0 / Math.tan(fovy * 0.5);
        const nf = 1.0 / (near - far);
      
        return new Float32Array([
          f / aspect, 0, 0, 0,
          0, f, 0, 0,
          0, 0, far * nf, -1,
          0, 0, (near * far) * nf, 0,
        ]);
      }

      function mat4Ortho(left, right, bottom, top, near, far) {
        const lr = 1 / (left - right);
        const bt = 1 / (bottom - top);
        const nf = 1 / (near - far);

        return new Float32Array([
          -2 * lr, 0, 0, 0,
          0, -2 * bt, 0, 0,
          0, 0, nf, 0,
          (left + right) * lr, (top + bottom) * bt, near * nf, 1,
        ]);
      }

      //-----------------------------------------------------------------------
      // Primitives
      //-----------------------------------------------------------------------

      function createBox(width, height, length) {
        const w = width/2.0;
        const h = height/2.0;
        const l = length/2.0;
        const positions = [
          -w, -h,  l,
           w, -h,  l,
           w,  h,  l,
          -w,  h,  l,
          -w, -h, -l,
           w, -h, -l,
           w,  h, -l,
          -w,  h, -l,
        ];
        const den = Math.sqrt (w*w + h*h + l*l);
        const wn = w/den;
        const hn = h/den;
        const ln = l/den;
        const normals = [
          -wn, -hn,  ln,
           wn, -hn,  ln,
           wn,  hn,  ln,
          -wn,  hn,  ln,
          -wn, -hn, -ln,
           wn, -hn, -ln,
           wn,  hn, -ln,
          -wn,  hn, -ln,
        ];
        const uvs = [
          0.375, 0.750, 
          0.625, 0.750, 
          0.625, 1.0, 
          0.375, 1.0, 
          0.375, 0.250, 
          0.625, 0.250,  
          0.625, 0.5, 
          0.375, 0.5, 
        ];
        const indices = [
          0, 1, 2,
          0, 2, 3,
          1, 5, 6,
          1, 6, 2,
          5, 4, 7,
          5, 7, 6,
          4, 0, 3,
          4, 3, 7,
          3, 2, 6,
          3, 6, 7,
          4, 5, 1,
          4, 1, 0,
        ];
        const mesh = {
          positions: new Float32Array(positions),
          normals: new Float32Array(normals),
          uvs: new Float32Array(uvs),
          indices:
            positions.length / 3 > 65535
              ? new Uint32Array(indices)
              : new Uint16Array(indices)
        };
        return mesh;
      }

      function createCube(size) {
        return createBox(size, size, size);
      }

      function createSphere(radius, latitudeRes, longitudeRes) {
        const positions = [];
        const normals = [];
        const uvs = [];
        const indices = [];
      
        for (let lat = 0; lat <= latitudeRes; lat++) {
          const theta = lat * Math.PI / latitudeRes;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
      
          for (let lon = 0; lon <= longitudeRes; lon++) {
            const phi = lon * 2 * Math.PI / longitudeRes;
            const sinPhi = Math.sin(phi);
            const cosPhi = Math.cos(phi);
      
            const x = cosPhi * sinTheta;
            const y = cosTheta;
            const z = sinPhi * sinTheta;
      
            positions.push(radius * x, radius * y, radius * z);
            normals.push(x, y, z);
            uvs.push(lon / longitudeRes, 1 - lat / latitudeRes);
          }
        }
      
        for (let lat = 0; lat < latitudeRes; lat++) {
          for (let lon = 0; lon < longitudeRes; lon++) {
            const first = lat * (longitudeRes + 1) + lon;
            const second = first + longitudeRes + 1;
      
            indices.push(
              first, second, first + 1,
              second, second + 1, first + 1
            );
          }
        }
      
        const mesh = {
          positions: new Float32Array(positions),
          normals: new Float32Array(normals),
          uvs: new Float32Array(uvs),
          indices:
            positions.length / 3 > 65535
              ? new Uint32Array(indices)
              : new Uint16Array(indices)
        };
        return mesh;
      }

      function vec3Length(x) {
        return Math.sqrt (x[0]*x[0] + x[1]*x[1] + x[2]*x[2]);
      }

      function vec3Cross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }

      function vec3Normalize (x) {
        const l = vec3Length (x);
        return [x[0]/l, x[1]/l, x[2]/l];
      }

      // Assumes the normal array exists at the right size
      function computeNormals(mesh) {
        const numOfTri = mesh.indices.length/3;
        const length = mesh.normals.length;
        for (let i = 0; i < length; ++i) {
          mesh.normals[i] = 0.0;
        }
        for (let i = 0; i < numOfTri; ++i) {
          const v0 = mesh.indices[3*i];
          const v1 = mesh.indices[3*i+1];
          const v2 = mesh.indices[3*i+2];
          const p0 = [mesh.positions[3*v0], mesh.positions[3*v0+1], mesh.positions[3*v0+2]]; 
          const p1 = [mesh.positions[3*v1], mesh.positions[3*v1+1], mesh.positions[3*v1+2]]; 
          const p2 = [mesh.positions[3*v2], mesh.positions[3*v2+1], mesh.positions[3*v2+2]];
          const e01 = [p1[0]-p0[0], p1[1]-p0[1], p1[2]-p0[2]]; 
          const e12 = [p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]];
          const c = vec3Cross (e01, e12);
          const l = vec3Length(c);
          const nt = [c[0]/l, c[1]/l, c[2]/l];
          mesh.normals[3*v0] += nt[0]; 
          mesh.normals[3*v0+1] += nt[1]; 
          mesh.normals[3*v0+2] += nt[2]; 
          mesh.normals[3*v1] += nt[0]; 
          mesh.normals[3*v1+1] += nt[1]; 
          mesh.normals[3*v1+2] += nt[2]; 
          mesh.normals[3*v2 ] += nt[0]; 
          mesh.normals[3*v2 +1] += nt[1]; 
          mesh.normals[3*v2 +2] += nt[2]; 
        }
        for (let i = 0; i < length/3; ++i) {
          const ni = [mesh.normals[3*i], mesh.normals[3*i+1], mesh.normals[3*i+2]];
          const nni = vec3Normalize (ni);
          mesh.normals[3*i] = nni[0]; 
          mesh.normals[3*i+1] = nni[1]; 
          mesh.normals[3*i+2] = nni[2]; 
        }
      }

      function createCornellBox() {
        const positions = [
          // White floor
          552.8, 0.0,   0.0,   
            0.0, 0.0,   0.0,
            0.0, 0.0, 559.2,
          549.6, 0.0, 559.2,
          // White Ceiling
          556.0, 548.8, 0.0,   
          556.0, 548.8, 559.2,
            0.0, 548.8, 559.2,
            0.0, 548.8,   0.0,
          // Back white wall
          549.6,   0.0, 559.2, 
            0.0,   0.0, 559.2,
            0.0, 548.8, 559.2,
          556.0, 548.8, 559.2,
          // Right green wall
          0.0,   0.0, 559.2,   
          0.0,   0.0,   0.0,
          0.0, 548.8,   0.0,
          0.0, 548.8, 559.2,
          // Left red wall
          552.8,   0.0,   0.0, 
          549.6,   0.0, 559.2,
          556.0, 548.8, 559.2,
          556.0, 548.8,   0.0,
          // Short white block
          130.0, 165.0,  65.0, 
           82.0, 165.0, 225.0,
          240.0, 165.0, 272.0,
          290.0, 165.0, 114.0,

          290.0,   0.0, 114.0,
          290.0, 165.0, 114.0,
          240.0, 165.0, 272.0,
          240.0,   0.0, 272.0,

          130.0,   0.0,  65.0,
          130.0, 165.0,  65.0,
          290.0, 165.0, 114.0,
          290.0,   0.0, 114.0,

           82.0,   0.0, 225.0,
           82.0, 165.0, 225.0,
          130.0, 165.0,  65.0,
          130.0,   0.0,  65.0,

          240.0,   0.0, 272.0,
          240.0, 165.0, 272.0,
           82.0, 165.0, 225.0,
           82.0,   0.0, 225.0,

           // Tall white block
           423.0, 330.0, 247.0,
           265.0, 330.0, 296.0,
           314.0, 330.0, 456.0,
           472.0, 330.0, 406.0,

           423.0,   0.0, 247.0,
           423.0, 330.0, 247.0,
           472.0, 330.0, 406.0,
           472.0,   0.0, 406.0,

           472.0,   0.0, 406.0,
           472.0, 330.0, 406.0,
           314.0, 330.0, 456.0,
           314.0,   0.0, 456.0,

           314.0,   0.0, 456.0,
           314.0, 330.0, 456.0,
           265.0, 330.0, 296.0,
           265.0,   0.0, 296.0,

           265.0,   0.0, 296.0,
           265.0, 330.0, 296.0,
           423.0, 330.0, 247.0,
           423.0,   0.0, 247.0,
        ];
        const normals = [
          // White floor
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          // White Ceiling
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          // Back white wall
          0, 0, -1, 
          0, 0, -1, 
          0, 0, -1, 
          0, 0, -1,
          // Right green wall
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0,  
          // Left red wall
          -1, 0, 0, 
          -1, 0, 0, 
          -1, 0, 0, 
          -1, 0, 0,
          // Short whie block
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          // Tall whie block
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,  
        ];
        const colors = [
          // White floor
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          // White Ceiling
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          // Back green wall
          0, 1, 0, 
          0, 1, 0, 
          0, 1, 0, 
          0, 1, 0,
          // Right blue wall
          0, 0, 1, 
          0, 0, 1, 
          0, 0, 1, 
          0, 0, 1, 
          // Left red wall
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0, 
          // Short whie block 
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          // Tall whie block 
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
        ];
        const uvs = [
          // White floor
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,
          // White Ceiling
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Back white wall
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Right green wall
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Left red wall
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,
          // Short white block
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Tall white block
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,
        ];
        const indices = [
          // White floor
          0, 1, 2,
          0, 2, 3,
          // White Ceiling
          4, 5, 6,
          4, 6, 7,
          // Back white wall
          8, 9, 10,
          8, 10,11,
          // Right green wall
          12, 13, 14,
          12, 14, 15,
          // Left red wall
          16, 17, 18,
          16, 18, 19,
          // Short white block
          20, 21, 22,
          20, 22, 23,

          24, 25, 26,
          24, 26, 27,

          28, 29, 30,
          28, 30, 31,

          32, 33, 34,
          32, 34, 35,

          36, 37, 38, 
          36, 38, 39,
          // Tall white block
          40, 41, 42,
          40, 42, 43,

          44, 45, 46,
          44, 46, 47,

          48, 49, 50, 
          48, 50, 51,

          52, 53, 54,
          52, 54, 55,

          56, 57, 58,
          56, 58, 59,
        ];
        const mesh = {
          positions: new Float32Array(positions),
          normals: new Float32Array(normals),
          colors: new Float32Array(colors),
          uvs: new Float32Array(uvs),
          indices: new Uint32Array(indices)
        };
        computeNormals (mesh);
        return mesh;
      }

      //-----------------------------------------------------------------------
      // Camera
      //-----------------------------------------------------------------------

      function getCameraPosition(camera) {
        return [
          camera.target[0] + camera.radius * Math.cos(camera.pitch) * Math.sin(camera.yaw),
          camera.target[1] + camera.radius * Math.sin(camera.pitch),
          camera.target[2] + camera.radius * Math.cos(camera.pitch) * Math.cos(camera.yaw)
        ];
      }

      function pan(camera, dx, dy) {
        const cosYaw = Math.cos(camera.yaw);
        const sinYaw = Math.sin(camera.yaw);

        // right vector
        const rightX = cosYaw;
        const rightZ = -sinYaw;

        // up vector (world up)
        const upX = 0;
        const upY = 1;
        const upZ = 0;

        const scale = camera.radius * camera.panSpeed;

        camera.target[0] -= (rightX * dx - upX * dy) * scale;
        camera.target[1] -= dy * scale;
        camera.target[2] -= (rightZ * dx - upZ * dy) * scale;
      }

      function lookAt(out, eye, target, up) {
        let zx = eye[0] - target[0];
        let zy = eye[1] - target[1];
        let zz = eye[2] - target[2];

        let len = Math.hypot(zx, zy, zz);
        zx /= len; zy /= len; zz /= len;

        let xx = up[1] * zz - up[2] * zy;
        let xy = up[2] * zx - up[0] * zz;
        let xz = up[0] * zy - up[1] * zx;

        len = Math.hypot(xx, xy, xz);
        xx /= len; xy /= len; xz /= len;

        const yx = zy * xz - zz * xy;
        const yy = zz * xx - zx * xz;
        const yz = zx * xy - zy * xx;

        out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
        out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
        out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
        out[12] = -(xx * eye[0] + xy * eye[1] + xz * eye[2]);
        out[13] = -(yx * eye[0] + yy * eye[1] + yz * eye[2]);
        out[14] = -(zx * eye[0] + zy * eye[1] + zz * eye[2]);
        out[15] = 1;
      }

      function updateCamera(camera) {
        const eye = getCameraPosition(camera);
        lookAt(camera.viewMat, eye, camera.target, camera.up);
      }

      function createCamera (aspect) {
        const camera = {};
        camera.modelMat = mat4Identity(0, 0, 0);
        camera.viewMat  = mat4Identity(); 
        // Intrinsic parameters
        camera.fov = Math.PI / 4.0;
        camera.aspect = aspect;
        camera.near = 0.1;
        camera.far = 10000.0;
        camera.projMat  = mat4Perspective(
          camera.fov,
          camera.aspect,
          camera.near,
          camera.far
        );
        camera.yaw = Math.PI;
        camera.pitch = 0;
        camera.radius = 1000;
        
        camera.target = [280, 280, 280];
        camera.up = [0, 1, 0];
        
        camera.rotateSpeed = 0.005;
        camera.zoomSpeed = 0.001;
        camera.panSpeed = 0.002;
        
        camera.minRadius = 1;
        camera.maxRadius = 10000;
  
        camera.dragging = false;
        camera.panning = false;
        camera.lastX = 0;
        camera.lastY = 0;
        return camera;
      }

      //-----------------------------------------------------------------------
      // Scene
      //-----------------------------------------------------------------------

      function createScene(camAspect) {
        const scene = {
          camera: createCamera(camAspect),
          lightSource: {
            position: [280.0, 400.0, -800.0],
            color: [1.0, 1.0, 1.0],
            lightViewMat: mat4Identity(),
            // lightProjMat: mat4Ortho(-400, 400, -400, 400, 0.1, 1000.0), // for directional light
            lightProjMat: mat4Perspective(
              Math.PI / 4.0,
              camAspect,
              1.0,
              2000.0
            ),
          },
          //mesh: createCube(1.2),
          //mesh: createSphere(0.8, 32, 32),
          mesh: createCornellBox(),
          time: 0,
        };
        lookAt(scene.lightSource.lightViewMat, scene.lightSource.position, [280.0, 280.0, 280.0], [0, 1, 0]);
        return scene;
      }

      async function createGPUApp() {
        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }
        const GPUApp = {
          // Components used for setting up the graphics environment
          canvas: {},
          // Implementation of WebGPU
          adapter: {},
          // GPU interface to create objects on the GPU
          device: {},
          // Configures WebGPU
          context: {},
          canvasFormat: {},
          // GPU memory story the mesh data
          meshBuffers:{},
          // GPU memory used to pass parameters from CPU to GPU, such as the camera or light properties
          uniformBuffer: {},
          uniformBufferForShadow: {},
          uniformBufferForDebug: {},
          // Handle on GPU parameters
          bindGroup: {},
          bindGroupForShadow: {},
          bindGroupForDebug: {},
          // Handle on the GPU shaders
          shaderModule: {},
          // Shadow code used for rendering
          shadowShaderModule: {},
          // Debug code
          debugShaderModule: {},
          // Organization of the input of the pipeline/vertex shader
          vertexBuffersLayout: {},
          vertexBuffersLayoutForShadow: {},
          // Organization of the 
          bindGroupLayout: {},
          bindGroupLayoutForShadow: {},
          bindGroupLayoutForDebug: {},
          // Rasterization pipeline
          rasterizationPipeline: {},
          // Shadow pipeline
          shadowPipeline: {},
          // Debug pipeline (to simulate the first images of the paper and help in debugging)
          debugPipeline: {},
          // Depth map used to store per-pixel depth (Z-Buffer)
          depthTexture: {},
          // Shadow depth map
          shadowDepthTexture: {},
          // Other textures for reflective shadow mapping
          shadowPositionTexture: {},
          shadowNormalTexture: {},
          shadowFluxTexture: {},
          // Model/View/Inverse View/Projection matrix (16 floats each), light position (3+1 pad floats), color (3+1 pad float), fov  (1+3 pad float), aspectRatio (1+3 pad fsloat)
          uniformData : new Float32Array(72),
          uniformDataForShadow : new Float32Array(16+16+4),
          uniformDataForDebug : new Uint32Array(32),
        };
        GPUApp.canvas = document.querySelector("canvas"),
        GPUApp.adapter = await navigator.gpu.requestAdapter();
        if (!GPUApp.adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }
        GPUApp.device = await GPUApp.adapter.requestDevice();
        GPUApp.context = GPUApp.canvas.getContext("webgpu");
        GPUApp.canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        GPUApp.context.configure({
          device: GPUApp.device,
          format: GPUApp.canvasFormat,
          alphaMode: "opaque",
        });
        return GPUApp;
      }

      function createGPUBuffer(device, data, usage) {
        const buffer = device.createBuffer({
          size: (data.byteLength + 3) & ~3, // 4-byte aligned
          usage
        });
        device.queue.writeBuffer(buffer, 0, data);
      
        return buffer;
      }

      function createMeshBuffers(GPUApp, mesh) {
        return {
          positionBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.positions,
            GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),
          
          normalBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.normals,
            GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),

          colorBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.colors,
            GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),
          
          uvBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.uvs,
            GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
          ),
          
          indexBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.indices,
            GPUBufferUsage.INDEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),
          
          indexFormat: "uint32"
        };
      }

      function createVertexBuffersLayoutForShadow() {
        return [
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" } // position
            ]
          },
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 1, offset: 0, format: "float32x3" } // normal
            ]
          },
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 2, offset: 0, format: "float32x3" } // color
            ]
          }
        ];
      }
      
      function createVertexBuffersLayout() {
        return [
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" } // position
            ]
          },
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 1, offset: 0, format: "float32x3" } // normal
            ]
          },
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 2, offset: 0, format: "float32x3" } // color
            ]
          },
          {
            arrayStride: 2 * 4,
            attributes: [
              { shaderLocation: 3, offset: 0, format: "float32x2" } // uv
            ]
          }
        ];
      }

      // Create and fill the GPU buffers used to store the geometry to render
      function initGPUBuffers(GPUApp, scene) {

        GPUApp.meshBuffers = createMeshBuffers(GPUApp, scene.mesh);

        GPUApp.uniformBuffer = createGPUBuffer(
          GPUApp.device, 
          GPUApp.uniformData, 
          GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        );

        GPUApp.uniformBufferForShadow = createGPUBuffer(
          GPUApp.device, 
          GPUApp.uniformDataForShadow, 
          GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        );

        GPUApp.uniformBufferForDebug = createGPUBuffer(
          GPUApp.device, 
          GPUApp.uniformDataForDebug, 
          GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        );

        GPUApp.bindGroupForShadow = GPUApp.device.createBindGroup({
          layout: GPUApp.bindGroupLayoutForShadow,
          entries: [{
            binding: 0,
            resource: { buffer: GPUApp.uniformBufferForShadow },
          }],
         });

        GPUApp.bindGroup = GPUApp.device.createBindGroup({
          layout: GPUApp.bindGroupLayout,
          entries: [{
            binding: 0,
            resource: { buffer: GPUApp.uniformBuffer },
          },
          {
            binding: 1,
            resource: GPUApp.shadowDepthTexture.createView(),
          },
          {
            binding: 2,
            resource: GPUApp.shadowPositionTexture.createView(),
          },
          {
            binding: 3,
            resource: GPUApp.shadowNormalTexture.createView(),
          },
          {
            binding: 4,
            resource: GPUApp.shadowFluxTexture.createView(),
          },
          {
            binding: 5,
            resource: GPUApp.device.createSampler({
              compare: "less",
              magFilter: "linear",
              minFilter: "linear",
              mipmapFilter: "linear",
            }),
          }],
         });

        GPUApp.bindGroupForDebug = GPUApp.device.createBindGroup({
          layout: GPUApp.bindGroupLayoutForDebug,
          entries: [{
            binding: 0,
            resource: { buffer: GPUApp.uniformBufferForDebug },
          },
          {
            binding: 1,
            resource: GPUApp.shadowDepthTexture.createView(),
          },
          {
            binding: 2,
            resource: GPUApp.shadowPositionTexture.createView(),
          },
          {
            binding: 3,
            resource: GPUApp.shadowNormalTexture.createView(),
          },
          {
            binding: 4,
            resource: GPUApp.shadowFluxTexture.createView(),
          }],
        });
      }

      function initRenderPipeline(GPUApp) {
        const shaders = document.getElementById("main-shaders").textContent;
        const shadowShaders = document.getElementById("shadow-shaders").textContent;
        const debugShaders = document.getElementById("debug-shaders").textContent;
        GPUApp.shaderModule = GPUApp.device.createShaderModule({
          label: "Shaders",
          code: shaders
        });
        GPUApp.shadowShaderModule = GPUApp.device.createShaderModule({
          label: "Shadow Shaders",
          code: shadowShaders
        });
        GPUApp.debugShaderModule = GPUApp.device.createShaderModule({
          label: "Debug Shaders",
          code: debugShaders
        });

        GPUApp.vertexBuffersLayoutForShadow = createVertexBuffersLayoutForShadow();
        GPUApp.vertexBuffersLayout = createVertexBuffersLayout();

        GPUApp.bindGroupLayoutForShadow = GPUApp.device.createBindGroupLayout({
          entries: [{
            binding: 0,
            visibility: GPUShaderStage.VERTEX,
            buffer: { type: "uniform" },
          }],
        });

        GPUApp.bindGroupLayout = GPUApp.device.createBindGroupLayout({
          entries: [{
            binding: 0,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "uniform" },
          },
          {
            binding: 1,
            visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
            texture: { sampleType: "depth" },
          },
          {
            binding: 2,
            visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
            texture: { sampleType: "float" },
          },
          {
            binding: 3,
            visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
            texture: { sampleType: "float" },
          },
          {
            binding: 4,
            visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
            texture: { sampleType: "float" },
          },
          {
            binding: 5,
            visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
            sampler: { type: "comparison" },
          }],
        });  

        GPUApp.bindGroupLayoutForDebug = GPUApp.device.createBindGroupLayout({
          entries: [{
            binding: 0,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "uniform" },
          },
          {
            binding: 1,
            visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
            texture: { sampleType: "depth" },
          },
          {
            binding: 2,
            visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
            texture: { sampleType: "float" },
          },
          {
            binding: 3,
            visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
            texture: { sampleType: "float" },
          },
          {
            binding: 4,
            visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,
            texture: { sampleType: "float" },
          }],
        });

        GPUApp.rasterizationPipeline = GPUApp.device.createRenderPipeline({
            label: "rasterizationPipeline",
            //layout: "auto",
            layout: GPUApp.device.createPipelineLayout({
              bindGroupLayouts: [GPUApp.bindGroupLayout],
            }),
            vertex: {
              module: GPUApp.shaderModule,
              entryPoint: "rasterVertexMain",
              buffers: GPUApp.vertexBuffersLayout
            },
            fragment: {
              module: GPUApp.shaderModule,
              entryPoint: "rasterFragmentMain",
              targets: [{
                format: GPUApp.canvasFormat
              }]
            },
            primitive: {
              topology: "triangle-list", // use "line-list" for sanity check
              cullMode: "back", // activate backface culling
            },
            depthStencil: {
              format: "depth24plus",   // Must match depth texture
              depthWriteEnabled: true,
              depthCompare: "less",    // Standard depth (Z) test
          },
        });

        // Texture used for the Z-Buffer depth test
        GPUApp.depthTexture = GPUApp.device.createTexture({
          size: [GPUApp.canvas.width, GPUApp.canvas.height],
          format: "depth24plus",
          usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });

        // Texture used for the shadow map
        GPUApp.shadowDepthTexture = GPUApp.device.createTexture({
          size: [512, 512],
          format: "depth32float",
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
        });

        GPUApp.shadowPositionTexture = GPUApp.device.createTexture({
          size: [512, 512],
          format: "rgba16float",
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
        });

        GPUApp.shadowNormalTexture = GPUApp.device.createTexture({
          size: [512, 512],
          format: "rgba16float",
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
        });

        GPUApp.shadowFluxTexture = GPUApp.device.createTexture({
          size: [512, 512],
          format: "rgba16float",
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
        });

        GPUApp.shadowPipeline = GPUApp.device.createRenderPipeline({
            label: "shadowPipeline",
            //layout: "auto",
            layout: GPUApp.device.createPipelineLayout({
              bindGroupLayouts: [GPUApp.bindGroupLayoutForShadow],
            }),
            vertex: {
              module: GPUApp.shadowShaderModule,
              entryPoint: "shadowVertexMain",
              buffers: GPUApp.vertexBuffersLayoutForShadow
            },
            primitive: {
              topology: "triangle-list", // use "line-list" for sanity check
              cullMode: "back", // activate backface culling
            },
            depthStencil: {
              format: "depth32float",   // Must match depth texture
              depthWriteEnabled: true,
              depthCompare: "less",    // Standard depth (Z) test
            },
            fragment: {
                module: GPUApp.shadowShaderModule,
                entryPoint: "shadowFragmentMain",
                targets: [
                  { format: "rgba16float" }, // position
                  { format: "rgba16float" }, // normal
                  { format: "rgba16float" }, // flux
                ]
              },
        });

        GPUApp.debugPipeline = GPUApp.device.createRenderPipeline({
          label: "debugPipeline",
          //layout: "auto",
          layout: GPUApp.device.createPipelineLayout({
            bindGroupLayouts: [GPUApp.bindGroupLayoutForDebug],
          }),
          vertex: {
            module: GPUApp.debugShaderModule,
            entryPoint: "debugVertexMain",
            buffers: []
          },
          fragment: {
            module: GPUApp.debugShaderModule,
            entryPoint: "debugFragmentMain",
            targets: [{
              format: GPUApp.canvasFormat
            }]
          },
          primitive: {
            topology: "triangle-list", // use "line-list" for sanity check
          },
        });
      }

      function initEvents (GPUApp, scene) {
        GPUApp.canvas.addEventListener("mousedown", e => {
          scene.camera.lastX = e.clientX;
          scene.camera.lastY = e.clientY;

          if (e.button === 0) scene.camera.dragging = true;   // left = rotate
          if (e.button === 1 || e.button === 2) scene.camera.panning = true; // middle/right = pan
        });

        window.addEventListener("mouseup", () => {
          scene.camera.dragging = false;
          scene.camera.panning = false;
        });

        GPUApp.canvas.addEventListener("mousemove", e => {
          const dx = e.clientX - scene.camera.lastX;
          const dy = e.clientY - scene.camera.lastY;
          scene.camera.lastX = e.clientX;
          scene.camera.lastY = e.clientY;

          if (scene.camera.dragging) {
            scene.camera.yaw   -= dx * scene.camera.rotateSpeed;
            scene.camera.pitch += dy * scene.camera.rotateSpeed;

            const maxPitch = Math.PI / 2 - 0.01;
            scene.camera.pitch = Math.max(-maxPitch, Math.min(maxPitch, scene.camera.pitch));
          }

          if (scene.camera.panning) {
            pan(scene.camera, dx, -dy);
          }
        });

        GPUApp.canvas.addEventListener("wheel", e => {
          e.preventDefault();
          scene.camera.radius *= 1 + e.deltaY * scene.camera.zoomSpeed;
          scene.camera.radius = Math.max(scene.camera.minRadius, Math.min(scene.camera.maxRadius, scene.camera.radius));
        }, { passive: false });

        GPUApp.canvas.addEventListener("contextmenu", e => e.preventDefault());
      }

      function animate(scene) {
        scene.time += 1.0;
        const angle = scene.time/40.0;
        scene.lightSource.position = [200.0*Math.cos (angle) + 280, 280, -280.0];
        lookAt(scene.lightSource.lightViewMat, scene.lightSource.position, scene.camera.target, scene.camera.up);
      }

      function updateUniforms(GPUApp, scene) {
        updateCamera(scene.camera);
        let lightMVP = mat4Multiply(scene.lightSource.lightProjMat, scene.lightSource.lightViewMat);
        GPUApp.uniformData.set(scene.camera.modelMat, 0);
        GPUApp.uniformData.set(scene.camera.viewMat, 16);
        GPUApp.uniformData.set(scene.camera.projMat, 32);
        GPUApp.uniformData.set(lightMVP, 48);
        GPUApp.uniformData.set(scene.lightSource.position, 64);
        GPUApp.uniformData[67] = 1.0; // pad
        GPUApp.uniformData.set(scene.lightSource.color, 68);
        GPUApp.uniformData[71] = 1.0; // pad
        GPUApp.device.queue.writeBuffer(
          GPUApp.uniformBuffer,
          0,
          GPUApp.uniformData.buffer,
          GPUApp.uniformData.byteOffset,
          GPUApp.uniformData.byteLength
        );
      }

      function updateUniformsForShadow(GPUApp, scene) {
        let lightMVP = mat4Multiply(scene.lightSource.lightProjMat, scene.lightSource.lightViewMat);
        GPUApp.uniformDataForShadow.set(lightMVP, 0);
        GPUApp.uniformDataForShadow.set(scene.camera.modelMat, 16);
        GPUApp.uniformDataForShadow.set(scene.lightSource.color, 32);
        GPUApp.uniformDataForShadow[35] = 1.0; // pad
        GPUApp.device.queue.writeBuffer(
          GPUApp.uniformBufferForShadow,
          0,
          GPUApp.uniformDataForShadow.buffer,
          GPUApp.uniformDataForShadow.byteOffset,
          GPUApp.uniformDataForShadow.byteLength
        );
      }

      function updateUniformsForDebug(GPUApp, debugViewInt) {
        GPUApp.uniformDataForDebug[0] = debugViewInt;
        GPUApp.device.queue.writeBuffer(
          GPUApp.uniformBufferForDebug,
          0,
          GPUApp.uniformDataForDebug.buffer,
          GPUApp.uniformDataForDebug.byteOffset,
          GPUApp.uniformDataForDebug.byteLength
        );
      }

      function render(GPUApp, scene) {
        if (document.getElementById("animateCheckbox").checked)
          animate(scene);
        const debugView = document.getElementById("debugSelect").value;
        updateUniforms(GPUApp, scene);
        updateUniformsForDebug(GPUApp, debugView == "none" ? 0 : debugView == "depth" ? 1 : debugView == "position" ? 2 : debugView == "normal" ? 3 : 4);
        updateUniformsForShadow(GPUApp, scene);
        const encoder = GPUApp.device.createCommandEncoder();
        const shadowPass = encoder.beginRenderPass({
          label: "Shadow map generation pass",
          colorAttachments: [
            {
              view: GPUApp.shadowPositionTexture.createView(),
              loadOp: "clear",
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              storeOp: "store",
            },
            {
              view: GPUApp.shadowNormalTexture.createView(),
              loadOp: "clear",
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              storeOp: "store",
            },
            {
              view: GPUApp.shadowFluxTexture.createView(),
              loadOp: "clear",
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              storeOp: "store",
            }
          ],
          depthStencilAttachment: {
            view: GPUApp.shadowDepthTexture.createView(),
            depthClearValue: 1.0,
            depthLoadOp: "clear",
            depthStoreOp: "store",
          },
        });
        shadowPass.setPipeline(GPUApp.shadowPipeline);
        shadowPass.setBindGroup(0, GPUApp.bindGroupForShadow);
        shadowPass.setVertexBuffer(0, GPUApp.meshBuffers.positionBuffer);
        shadowPass.setVertexBuffer(1, GPUApp.meshBuffers.normalBuffer);
        shadowPass.setVertexBuffer(2, GPUApp.meshBuffers.colorBuffer);
        shadowPass.setIndexBuffer(GPUApp.meshBuffers.indexBuffer, GPUApp.meshBuffers.indexFormat);
        shadowPass.drawIndexed(scene.mesh.indices.length);
        shadowPass.end();

        if (debugView == "none") {
          const renderPass = encoder.beginRenderPass({
            label: "Main rendering pass",
            colorAttachments: [{
              view: GPUApp.context.getCurrentTexture().createView(),
              loadOp: "clear",
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              storeOp: "store",
            }],
            sampleCount: 1,
            depthStencilAttachment: {
              view: GPUApp.depthTexture.createView(),
              depthClearValue: 1.0,
              depthLoadOp: "clear",
              depthStoreOp: "store",
            },
          });
          renderPass.setPipeline(GPUApp.rasterizationPipeline);
          renderPass.setBindGroup(0, GPUApp.bindGroup);
          renderPass.setVertexBuffer(0, GPUApp.meshBuffers.positionBuffer);
          renderPass.setVertexBuffer(1, GPUApp.meshBuffers.normalBuffer);
          renderPass.setVertexBuffer(2, GPUApp.meshBuffers.colorBuffer);
          renderPass.setVertexBuffer(3, GPUApp.meshBuffers.uvBuffer);
          renderPass.setIndexBuffer(GPUApp.meshBuffers.indexBuffer, GPUApp.meshBuffers.indexFormat);
          renderPass.drawIndexed(scene.mesh.indices.length);
          renderPass.end();
        }
        else {
          const debugPass = encoder.beginRenderPass({
            label: "Debug pass",
            colorAttachments: [{
              view: GPUApp.context.getCurrentTexture().createView(),
              loadOp: "clear",
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              storeOp: "store",
            }],
          });
          debugPass.setPipeline(GPUApp.debugPipeline);
          debugPass.setBindGroup(0, GPUApp.bindGroupForDebug);
          debugPass.draw(6);
          debugPass.end();
        }
        const commandBuffer = encoder.finish();
        GPUApp.device.queue.submit([commandBuffer]);
      }

      async function main() {
        const GPUApp = await createGPUApp();
        const camAspect = GPUApp.canvas.width/GPUApp.canvas.height;
        initRenderPipeline(GPUApp);
        const scene = createScene(camAspect);
        initEvents (GPUApp, scene);
        initGPUBuffers(GPUApp, scene);
        // Animate at 60Hz
        setInterval(function() { render(GPUApp, scene); }, 16.6);
      }

      main();

    </script>
  </body>
</html>