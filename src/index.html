<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>CSC-52084-EP - Assignment 2 - Ray tracing in WebGPU - Solution</title>
  </head>
  <body style="margin-left:20%; margin-right:20%; padding:0">
    <div style = "text-align:center;">
      <canvas width="1024" height="768"></canvas>
      <p>
      <input type="checkbox" id="raytracingCheckbox">
      <label for="raytracingCheckbox">Ray tracing</label>
      <input type="checkbox" id="raytracedShadowsCheckbox">
      <label for="raytracedShadowsCheckbox">Ray-traced shadows</label>
      <input type="checkbox" id="animateCheckbox">
      <label for="animateCheckbox">Animate</label>
      </p>
    </div>
    <div style = "text-align:left;">
      <p>
        This solution to Assignment 2 provides the <a href="https://bowers.cornell.edu/computer-graphics/data#cornellbox">Cornell Box</a>, and a ray tracing pipeline. 
      </p>
      <p>
        A few observations:
        <ul>
          <li> rays are computed using the inverse of the view matrix, computed once on CPU and passed along the other matrices to GPU as a <i>uniform</i> value</li>
          <li> the ray-triangle intersection routine is based on the course notes (see the slide deck), which is itself based the <a target="_blank" href="https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf">M&ouml;ller-Trumbose</a> algorithm</li>
          <li> this routine is used as is for testing light visibility i.e., shadows, but a simpler (more efficient) version can be used instead, as any hit is valid and no reconstruction of the actual intersection point is needed.</li>
        </ul>
        Beyond the algorithms to implement, a key aspect of this assignment resides in the CPU/GPU interop.:
        <ul>
         <li> additional <i>uniform</i> variables need to be passed to the GPU, while being careful about the <i>padding</i> (see the shader code)</li>
         <li> the fragment shader of the ray tracing pipeline (in charge of ray tracing the scene) accesses the mesh buffers as <i>storage buffers</i> for random queries; these buffer are bind differently than with the rasterization pipeline.</li>
         <li> the rasterized geometry isprocedurally defined in the ray tracing pipeline, entirely on GPU.
        </ul>
        You can refer to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API">WebGPU documentation</a> for more information about the actual WebGPU/WGSL code.
      </p> 
    </div>
    <script type="x-shader/wgsl" id="shaders">
      struct Uniforms {
        modelMat : mat4x4<f32>,
        viewMat : mat4x4<f32>,
        invViewMat: mat4x4<f32>,
        projMat : mat4x4<f32>,
        lightPosition : vec3<f32>,
        rayTracedShadows : u32,
        lightColor : vec3<f32>,
        _pad1 : f32,
        camFov: f32,
        camAspectRatio: f32,
        _pad2: vec2<f32>,
      };
      
      @group(0) @binding(0)
      var<uniform> uniforms : Uniforms;

      @group(0) @binding(1)
      var<storage, read> positions : array<f32>;

      @group(0) @binding(2)
      var<storage, read> normals : array<f32>;

      @group(0) @binding(3)
      var<storage, read> colors : array<f32>;

      @group(0) @binding(4)
      var<storage, read> triangles : array<u32>;
      
      struct RasterVertexInput {
        @location(0) pos: vec3f,
        @location(1) normal: vec3f,
        @location(2) color: vec3f,
        @location(3) uv: vec2f,  
        @builtin(instance_index) instance: u32
      };
  
      struct RasterVertexOutput {
        @builtin(position) builtInPos : vec4f,
        @location(0) position: vec3f,
        @location(1) normal: vec3f,
        @location(2) color: vec3f,
        @location(3) uv: vec2f,
      };

      fn ambientShade(baseColor: vec3f) -> vec3f {
        const ka = 0.1;
        var fa = vec3f (1.0, 1.0, 1.0);
        return ka * fa * baseColor;
      }
      
      fn lightShade(position: vec3f, normal: vec3f, baseColor: vec3f) -> vec3f {
        var wi = normalize (uniforms.lightPosition - position);
        var li = uniforms.lightColor;
        const kd = 0.9;
        var fd = li * max (0.0, dot (wi, normal));
        var colorResponse = kd * fd * baseColor;
        return colorResponse;
      }

      fn shade(position: vec3f, normal: vec3f, baseColor: vec3f) -> vec3f {
        var colorResponse = vec3f (0.0, 0.0, 0.0);
        colorResponse += ambientShade(baseColor);
        colorResponse += lightShade(position, normal, baseColor);
        return colorResponse;
      }


      //-----------------------------------------------------------------------
      // Rasterization shaders 
      //-----------------------------------------------------------------------
      
      @vertex
        fn rasterVertexMain(input: RasterVertexInput) -> RasterVertexOutput {
          var output: RasterVertexOutput;
          output.builtInPos = uniforms.projMat * uniforms.viewMat * uniforms.modelMat * vec4f (input.pos, 1);
          output.position = input.pos;
          output.normal = input.normal;
          output.color = input.color;
          output.uv = input.uv;
          return output;
        }

      @fragment
        fn rasterFragmentMain(input: RasterVertexOutput) -> @location(0) vec4f {
          var position = input.position;
          var normal = normalize (input.normal);
          var baseColor = input.color;
          var colorResponse = shade (position, normal, baseColor);
          return vec4f (colorResponse, 1.0);
        }

      //-----------------------------------------------------------------------
      // Ray tracing pipeline shaders
      //-----------------------------------------------------------------------

      struct RayVertexInput {
        @builtin(vertex_index) vertexIndex: u32
      };
  
      struct RayVertexOutput {
        @builtin(position) pos : vec4f,
      }; 

      struct RayFragmentInput {
        @builtin(position) fragPos : vec4f,
      };

      struct Ray {
        origin: vec3f,
        direction: vec3f,
      };

      struct Hit{
        index: u32,
        u: f32,
        v: f32,
        t: f32,
      };

      fn interpolate(x0: vec3f, x1: vec3f, x2: vec3f, uvw: vec3f) -> vec3f {
        return uvw.z * x0 + uvw.x * x1 + uvw.y * x2;
      }

      fn getVertPos(vertIndex: u32) -> vec3f {
        return vec3f (positions[3*vertIndex], positions[3*vertIndex+1], positions[3*vertIndex+2]);
      }

      fn getVertNormal(vertIndex: u32) -> vec3f {
        return vec3f (normals[3*vertIndex], normals[3*vertIndex+1], normals[3*vertIndex+2]);
      }

      fn getVertColor(vertIndex: u32) -> vec3f {
        return vec3f (colors[3*vertIndex], colors[3*vertIndex+1], colors[3*vertIndex+2]);
      }

      fn getTriangle(triIndex: u32) -> vec3u {
        return vec3u (triangles[3*triIndex], triangles[3*triIndex+1], triangles[3*triIndex+2]);
      }

      fn rayAt(uv: vec2f, invViewMat : mat4x4<f32>) -> Ray {
        var ray : Ray;
        var viewRight = normalize (invViewMat[0].xyz);
        var viewUp = normalize (invViewMat[1].xyz);
        var viewDir = -normalize (invViewMat[2].xyz);
        var eye = invViewMat[3].xyz;
        var fov = uniforms.camFov;
        var w = 2.0 * tan (0.5*fov); 
        ray.origin = eye;
        var aspectRatio = uniforms.camAspectRatio;
        ray.direction = normalize (viewDir + ((uv.x - 0.5) * aspectRatio * w) * viewRight + ((uv.y) - 0.5) * w * viewUp);  
        return ray;
      }

      fn intersectTriangle(
        ray: Ray, 
        p0: vec3f, 
        p1: vec3f, 
        p2: vec3f, 
        culling: bool,
        tMin: f32,
        tMax: f32,
        hit: ptr<function, Hit>
      ) -> bool {
        const EPSILON = 1e-6;
        var e1 = p1 - p0;
        var e2 = p2 - p0;
        var dxe2 = cross(ray.direction, e2);
        var det = dot(e1, dxe2);
        if ((culling && det < EPSILON) || (!culling && abs(det) < EPSILON)) {
          return false;
        }
        var invDet = 1.0 / det;
        var op0 = ray.origin - p0;
        (*hit).u = dot(op0, dxe2) * invDet;
        if ((*hit).u < 0.0 || (*hit).u > 1.f) {
          return false;
        }
        var op0xe1 = cross(op0, e1);
        (*hit).t = dot(e2, op0xe1) * invDet;
        if ((*hit).t < tMin || (*hit).t > tMax) {
          return false;
        }
        (*hit).v = dot(ray.direction, op0xe1) * invDet;
        if ((*hit).v >= 0.0 && (*hit).u + (*hit).v <= 1.0) {
          return true;
        }
        return false;
      }

      fn rayTrace(ray: Ray, hit: ptr<function, Hit>) -> bool {
        const MAX_DISTANCE = 1e8;
        var intersectionFound = false;
        for (var triIndex = 0u; triIndex < 100; triIndex++) {
          var triangle = getTriangle(triIndex);
          var triHit: Hit;
          triHit.index = triIndex;
          var p0 = getVertPos(triangle.x);
          var p1 = getVertPos(triangle.y);
          var p2 = getVertPos(triangle.z);
          if (intersectTriangle(ray, p0, p1, p2, true, 0.0, MAX_DISTANCE, &triHit) == true) {
            if (!intersectionFound || (intersectionFound && triHit.t < hit.t)) {
              *hit = triHit;
              intersectionFound = true;
            }
          }
        }
        return intersectionFound;
      }

      fn shadeRT(hit: Hit) -> vec4f {
        var tri = vec3u (triangles[3*hit.index], triangles[3*hit.index+1], triangles[3*hit.index+2]);
        var uvw = vec3f (hit.u, hit.v, 1.0 - hit.u - hit.v);
        var position = interpolate(getVertPos(tri.x), getVertPos(tri.y), getVertPos(tri.z), uvw);
        var normal = normalize(interpolate(getVertNormal(tri.x), getVertNormal(tri.y), getVertNormal(tri.z), uvw));
        var baseColor = interpolate(getVertColor(tri.x), getVertColor(tri.y), getVertColor(tri.z), uvw);
        var colorResponse = ambientShade (baseColor);
        if (bool(uniforms.rayTracedShadows) == true) {
          var shadowRay : Ray;
          const shadowBias = 0.0001;
          var pos2light = uniforms.lightPosition - position;
          var lightDist = length (pos2light);
          shadowRay.direction = normalize (pos2light);
          shadowRay.origin = position + shadowBias * normal;
          var shadowHit : Hit;
          var inShadow = rayTrace (shadowRay, &shadowHit);
          if (inShadow == false || (inShadow == true && shadowHit.t > lightDist)) {
            colorResponse += lightShade (position, normal, baseColor);
          }
        } else {
          colorResponse += lightShade (position, normal, baseColor);
        }
        return vec4f (colorResponse, 1.0);
      }

      @vertex
        fn rayVertexMain(input: RayVertexInput) -> RayVertexOutput {
          var output: RayVertexOutput;
          const screenPos = array<vec2<f32>, 6>(
              vec2f(-1.0, -1.0),
              vec2f( 1.0, -1.0),
              vec2f(-1.0,  1.0),
              vec2f(-1.0,  1.0),
              vec2f( 1.0, -1.0),
              vec2f( 1.0,  1.0),
          );
          output.pos = vec4f (screenPos[input.vertexIndex], 0.0, 1.0);
          return output;
        }

      @fragment
        fn rayFragmentMain(input: RayFragmentInput) -> @location(0) vec4f {
          var coord = vec2f (input.fragPos.x/1024, 1.0-input.fragPos.y/768);
          var ray = rayAt (coord, uniforms.invViewMat);
          var colorResponse = vec4f (0.0, 0.0, 0.0, 1.0);
          var hit: Hit;
          if (rayTrace (ray, &hit) == true) {
            colorResponse = shadeRT (hit);
          }
          return colorResponse;
        }
    </script>
    <script type="x-shader/wgsl" id="shadow-shaders">
      struct Uniforms {
        modelMat : mat4x4<f32>,
        depthMVP : mat4x4<f32>
      };

      @group(0) @binding(0)
      var<uniform> uniforms : Uniforms;
      
      struct ShadowVertexInput {
        @location(0) pos: vec3f,
      };

      struct ShadowVertexOutput {
        @builtin(position) builtInPos : vec4f,
      };

      @vertex
        fn shadowVertexMain(input: ShadowVertexInput) -> ShadowVertexOutput {
          var output: ShadowVertexOutput;
          output.builtInPos = uniforms.depthMVP * uniforms.modelMat * vec4f (input.pos, 1);
          return output;
        }
    </script>
    <script type="module">

      // Minimal 4x4 Matrix implementaton, to be used for the Model-View-Projection matrix

      function mat4Identity() {
        return new Float32Array([
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          0, 0, 0, 1,
        ]);
      }
      
      function mat4Translate(x, y, z) {
        const m = mat4Identity();
        m[12] = x;
        m[13] = y;
        m[14] = z;
        return m;
      }
      
      function mat4Multiply(a, b) {
        const out = new Float32Array(16);
        for (let col = 0; col < 4; col++) {
          for (let row = 0; row < 4; row++) {
            out[col * 4 + row] =
              a[0 * 4 + row] * b[col * 4 + 0] +
              a[1 * 4 + row] * b[col * 4 + 1] +
              a[2 * 4 + row] * b[col * 4 + 2] +
              a[3 * 4 + row] * b[col * 4 + 3];
          }
        }
        return out;
      }

      function mat4Invert(a) {
        const out = new Float32Array(16);

        const a00 = a[0],  a01 = a[1],  a02 = a[2],  a03 = a[3];
        const a10 = a[4],  a11 = a[5],  a12 = a[6],  a13 = a[7];
        const a20 = a[8],  a21 = a[9],  a22 = a[10], a23 = a[11];
        const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        const b00 = a00 * a11 - a01 * a10;
        const b01 = a00 * a12 - a02 * a10;
        const b02 = a00 * a13 - a03 * a10;
        const b03 = a01 * a12 - a02 * a11;
        const b04 = a01 * a13 - a03 * a11;
        const b05 = a02 * a13 - a03 * a12;
        const b06 = a20 * a31 - a21 * a30;
        const b07 = a20 * a32 - a22 * a30;
        const b08 = a20 * a33 - a23 * a30;
        const b09 = a21 * a32 - a22 * a31;
        const b10 = a21 * a33 - a23 * a31;
        const b11 = a22 * a33 - a23 * a32;

        // Determinant
        let det =
          b00 * b11 -
          b01 * b10 +
          b02 * b09 +
          b03 * b08 -
          b04 * b07 +
          b05 * b06;

        if (!det) return null;
        det = 1.0 / det;

        out[0]  = ( a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1]  = (-a01 * b11 + a02 * b10 - a03 * b09) * det;
        out[2]  = ( a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[3]  = (-a21 * b05 + a22 * b04 - a23 * b03) * det;

        out[4]  = (-a10 * b11 + a12 * b08 - a13 * b07) * det;
        out[5]  = ( a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[6]  = (-a30 * b05 + a32 * b02 - a33 * b01) * det;
        out[7]  = ( a20 * b05 - a22 * b02 + a23 * b01) * det;

        out[8]  = ( a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[9]  = (-a00 * b10 + a01 * b08 - a03 * b06) * det;
        out[10] = ( a30 * b04 - a31 * b02 + a33 * b00) * det;
        out[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * det;

        out[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * det;
        out[13] = ( a00 * b09 - a01 * b07 + a02 * b06) * det;
        out[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * det;
        out[15] = ( a20 * b03 - a21 * b01 + a22 * b00) * det;

        return out;
      }

      function mat4Perspective(fovy, aspect, near, far) {
        const f = 1.0 / Math.tan(fovy * 0.5);
        const nf = 1.0 / (near - far);
      
        return new Float32Array([
          f / aspect, 0, 0, 0,
          0, f, 0, 0,
          0, 0, far * nf, -1,
          0, 0, (near * far) * nf, 0,
        ]);
      }

      //-----------------------------------------------------------------------
      // Primitives
      //-----------------------------------------------------------------------

      function createBox(width, height, length) {
        const w = width/2.0;
        const h = height/2.0;
        const l = length/2.0;
        const positions = [
          -w, -h,  l,
           w, -h,  l,
           w,  h,  l,
          -w,  h,  l,
          -w, -h, -l,
           w, -h, -l,
           w,  h, -l,
          -w,  h, -l,
        ];
        const den = Math.sqrt (w*w + h*h + l*l);
        const wn = w/den;
        const hn = h/den;
        const ln = l/den;
        const normals = [
          -wn, -hn,  ln,
           wn, -hn,  ln,
           wn,  hn,  ln,
          -wn,  hn,  ln,
          -wn, -hn, -ln,
           wn, -hn, -ln,
           wn,  hn, -ln,
          -wn,  hn, -ln,
        ];
        const uvs = [
          0.375, 0.750, 
          0.625, 0.750, 
          0.625, 1.0, 
          0.375, 1.0, 
          0.375, 0.250, 
          0.625, 0.250,  
          0.625, 0.5, 
          0.375, 0.5, 
        ];
        const indices = [
          0, 1, 2,
          0, 2, 3,
          1, 5, 6,
          1, 6, 2,
          5, 4, 7,
          5, 7, 6,
          4, 0, 3,
          4, 3, 7,
          3, 2, 6,
          3, 6, 7,
          4, 5, 1,
          4, 1, 0,
        ];
        const mesh = {
          positions: new Float32Array(positions),
          normals: new Float32Array(normals),
          uvs: new Float32Array(uvs),
          indices:
            positions.length / 3 > 65535
              ? new Uint32Array(indices)
              : new Uint16Array(indices)
        };
        return mesh;
      }

      function createCube(size) {
        return createBox(size, size, size);
      }

      function createSphere(radius, latitudeRes, longitudeRes) {
        const positions = [];
        const normals = [];
        const uvs = [];
        const indices = [];
      
        for (let lat = 0; lat <= latitudeRes; lat++) {
          const theta = lat * Math.PI / latitudeRes;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
      
          for (let lon = 0; lon <= longitudeRes; lon++) {
            const phi = lon * 2 * Math.PI / longitudeRes;
            const sinPhi = Math.sin(phi);
            const cosPhi = Math.cos(phi);
      
            const x = cosPhi * sinTheta;
            const y = cosTheta;
            const z = sinPhi * sinTheta;
      
            positions.push(radius * x, radius * y, radius * z);
            normals.push(x, y, z);
            uvs.push(lon / longitudeRes, 1 - lat / latitudeRes);
          }
        }
      
        for (let lat = 0; lat < latitudeRes; lat++) {
          for (let lon = 0; lon < longitudeRes; lon++) {
            const first = lat * (longitudeRes + 1) + lon;
            const second = first + longitudeRes + 1;
      
            indices.push(
              first, second, first + 1,
              second, second + 1, first + 1
            );
          }
        }
      
        const mesh = {
          positions: new Float32Array(positions),
          normals: new Float32Array(normals),
          uvs: new Float32Array(uvs),
          indices:
            positions.length / 3 > 65535
              ? new Uint32Array(indices)
              : new Uint16Array(indices)
        };
        return mesh;
      }

      function vec3Length(x) {
        return Math.sqrt (x[0]*x[0] + x[1]*x[1] + x[2]*x[2]);
      }

      function vec3Cross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }

      function vec3Normalize (x) {
        const l = vec3Length (x);
        return [x[0]/l, x[1]/l, x[2]/l];
      }

      // Assumes the normal array exists at the right size
      function computeNormals(mesh) {
        const numOfTri = mesh.indices.length/3;
        const length = mesh.normals.length;
        for (let i = 0; i < length; ++i) {
          mesh.normals[i] = 0.0;
        }
        for (let i = 0; i < numOfTri; ++i) {
          const v0 = mesh.indices[3*i];
          const v1 = mesh.indices[3*i+1];
          const v2 = mesh.indices[3*i+2];
          const p0 = [mesh.positions[3*v0], mesh.positions[3*v0+1], mesh.positions[3*v0+2]]; 
          const p1 = [mesh.positions[3*v1], mesh.positions[3*v1+1], mesh.positions[3*v1+2]]; 
          const p2 = [mesh.positions[3*v2], mesh.positions[3*v2+1], mesh.positions[3*v2+2]];
          const e01 = [p1[0]-p0[0], p1[1]-p0[1], p1[2]-p0[2]]; 
          const e12 = [p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]];
          const c = vec3Cross (e01, e12);
          const l = vec3Length(c);
          const nt = [c[0]/l, c[1]/l, c[2]/l];
          mesh.normals[3*v0] += nt[0]; 
          mesh.normals[3*v0+1] += nt[1]; 
          mesh.normals[3*v0+2] += nt[2]; 
          mesh.normals[3*v1] += nt[0]; 
          mesh.normals[3*v1+1] += nt[1]; 
          mesh.normals[3*v1+2] += nt[2]; 
          mesh.normals[3*v2 ] += nt[0]; 
          mesh.normals[3*v2 +1] += nt[1]; 
          mesh.normals[3*v2 +2] += nt[2]; 
        }
        for (let i = 0; i < length/3; ++i) {
          const ni = [mesh.normals[3*i], mesh.normals[3*i+1], mesh.normals[3*i+2]];
          const nni = vec3Normalize (ni);
          mesh.normals[3*i] = nni[0]; 
          mesh.normals[3*i+1] = nni[1]; 
          mesh.normals[3*i+2] = nni[2]; 
        }
      }

      function createCornellBox() {
        const positions = [
          // White floor
          552.8, 0.0,   0.0,   
            0.0, 0.0,   0.0,
            0.0, 0.0, 559.2,
          549.6, 0.0, 559.2,
          // White Ceiling
          556.0, 548.8, 0.0,   
          556.0, 548.8, 559.2,
            0.0, 548.8, 559.2,
            0.0, 548.8,   0.0,
          // Back white wall
          549.6,   0.0, 559.2, 
            0.0,   0.0, 559.2,
            0.0, 548.8, 559.2,
          556.0, 548.8, 559.2,
          // Right green wall
          0.0,   0.0, 559.2,   
          0.0,   0.0,   0.0,
          0.0, 548.8,   0.0,
          0.0, 548.8, 559.2,
          // Left red wall
          552.8,   0.0,   0.0, 
          549.6,   0.0, 559.2,
          556.0, 548.8, 559.2,
          556.0, 548.8,   0.0,
          // Short white block
          130.0, 165.0,  65.0, 
           82.0, 165.0, 225.0,
          240.0, 165.0, 272.0,
          290.0, 165.0, 114.0,

          290.0,   0.0, 114.0,
          290.0, 165.0, 114.0,
          240.0, 165.0, 272.0,
          240.0,   0.0, 272.0,

          130.0,   0.0,  65.0,
          130.0, 165.0,  65.0,
          290.0, 165.0, 114.0,
          290.0,   0.0, 114.0,

           82.0,   0.0, 225.0,
           82.0, 165.0, 225.0,
          130.0, 165.0,  65.0,
          130.0,   0.0,  65.0,

          240.0,   0.0, 272.0,
          240.0, 165.0, 272.0,
           82.0, 165.0, 225.0,
           82.0,   0.0, 225.0,

           // Tall white block
           423.0, 330.0, 247.0,
           265.0, 330.0, 296.0,
           314.0, 330.0, 456.0,
           472.0, 330.0, 406.0,

           423.0,   0.0, 247.0,
           423.0, 330.0, 247.0,
           472.0, 330.0, 406.0,
           472.0,   0.0, 406.0,

           472.0,   0.0, 406.0,
           472.0, 330.0, 406.0,
           314.0, 330.0, 456.0,
           314.0,   0.0, 456.0,

           314.0,   0.0, 456.0,
           314.0, 330.0, 456.0,
           265.0, 330.0, 296.0,
           265.0,   0.0, 296.0,

           265.0,   0.0, 296.0,
           265.0, 330.0, 296.0,
           423.0, 330.0, 247.0,
           423.0,   0.0, 247.0,
        ];
        const normals = [
          // White floor
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          // White Ceiling
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          0, -1, 0,
          // Back white wall
          0, 0, -1, 
          0, 0, -1, 
          0, 0, -1, 
          0, 0, -1,
          // Right green wall
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0,  
          // Left red wall
          -1, 0, 0, 
          -1, 0, 0, 
          -1, 0, 0, 
          -1, 0, 0,
          // Short whie block
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          // Tall whie block
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,

          0, 1,  0,
          0, 1,  0,
          0, 1,  0,
          0, 1,  0,  
        ];
        const colors = [
          // White floor
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          // White Ceiling
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          // Back white wall
          1, 1, 1, 
          1, 1, 1, 
          1, 1, 1, 
          1, 1, 1,
          // Right green wall
          0, 1, 0, 
          0, 1, 0, 
          0, 1, 0, 
          0, 1, 0, 
          // Left red wall
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0, 
          1, 0, 0, 
          // Short whie block 
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          // Tall whie block 
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,

          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
          1, 1, 1,
        ];
        const uvs = [
          // White floor
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,
          // White Ceiling
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Back white wall
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Right green wall
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Left red wall
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,
          // Short white block
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1, 
          // Tall white block
          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,

          0, 0, 
          1, 0, 
          1, 1, 
          0, 1,
        ];
        const indices = [
          // White floor
          0, 1, 2,
          0, 2, 3,
          // White Ceiling
          4, 5, 6,
          4, 6, 7,
          // Back white wall
          8, 9, 10,
          8, 10,11,
          // Right green wall
          12, 13, 14,
          12, 14, 15,
          // Left red wall
          16, 17, 18,
          16, 18, 19,
          // Short white block
          20, 21, 22,
          20, 22, 23,

          24, 25, 26,
          24, 26, 27,

          28, 29, 30,
          28, 30, 31,

          32, 33, 34,
          32, 34, 35,

          36, 37, 38, 
          36, 38, 39,
          // Tall white block
          40, 41, 42,
          40, 42, 43,

          44, 45, 46,
          44, 46, 47,

          48, 49, 50, 
          48, 50, 51,

          52, 53, 54,
          52, 54, 55,

          56, 57, 58,
          56, 58, 59,
        ];
        const mesh = {
          positions: new Float32Array(positions),
          normals: new Float32Array(normals),
          colors: new Float32Array(colors),
          uvs: new Float32Array(uvs),
          indices: new Uint32Array(indices)
        };
        computeNormals (mesh);
        return mesh;
      }

      //-----------------------------------------------------------------------
      // Camera
      //-----------------------------------------------------------------------

      function getCameraPosition(camera) {
        return [
          camera.target[0] + camera.radius * Math.cos(camera.pitch) * Math.sin(camera.yaw),
          camera.target[1] + camera.radius * Math.sin(camera.pitch),
          camera.target[2] + camera.radius * Math.cos(camera.pitch) * Math.cos(camera.yaw)
        ];
      }

      function pan(camera, dx, dy) {
        const cosYaw = Math.cos(camera.yaw);
        const sinYaw = Math.sin(camera.yaw);

        // right vector
        const rightX = cosYaw;
        const rightZ = -sinYaw;

        // up vector (world up)
        const upX = 0;
        const upY = 1;
        const upZ = 0;

        const scale = camera.radius * camera.panSpeed;

        camera.target[0] -= (rightX * dx - upX * dy) * scale;
        camera.target[1] -= dy * scale;
        camera.target[2] -= (rightZ * dx - upZ * dy) * scale;
      }

      function lookAt(out, eye, target, up) {
        let zx = eye[0] - target[0];
        let zy = eye[1] - target[1];
        let zz = eye[2] - target[2];

        let len = Math.hypot(zx, zy, zz);
        zx /= len; zy /= len; zz /= len;

        let xx = up[1] * zz - up[2] * zy;
        let xy = up[2] * zx - up[0] * zz;
        let xz = up[0] * zy - up[1] * zx;

        len = Math.hypot(xx, xy, xz);
        xx /= len; xy /= len; xz /= len;

        const yx = zy * xz - zz * xy;
        const yy = zz * xx - zx * xz;
        const yz = zx * xy - zy * xx;

        out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
        out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
        out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
        out[12] = -(xx * eye[0] + xy * eye[1] + xz * eye[2]);
        out[13] = -(yx * eye[0] + yy * eye[1] + yz * eye[2]);
        out[14] = -(zx * eye[0] + zy * eye[1] + zz * eye[2]);
        out[15] = 1;
      }

      function updateCamera(camera) {
        const eye = getCameraPosition(camera);
        lookAt(camera.viewMat, eye, camera.target, camera.up);
      }

      function createCamera (aspect) {
        const camera = {};
        camera.modelMat = mat4Identity(0, 0, 0);
        camera.viewMat  = mat4Identity(); 
        // Intrinsic parameters
        camera.fov = Math.PI / 4.0;
        camera.aspect = aspect;
        camera.near = 0.1;
        camera.far = 10000.0;
        camera.projMat  = mat4Perspective(
          camera.fov,
          camera.aspect,
          camera.near,
          camera.far
        );
        camera.yaw = Math.PI;
        camera.pitch = 0;
        camera.radius = 1000;
        
        camera.target = [280, 280, 280];
        camera.up = [0, 1, 0];
        
        camera.rotateSpeed = 0.005;
        camera.zoomSpeed = 0.001;
        camera.panSpeed = 0.002;
        
        camera.minRadius = 1;
        camera.maxRadius = 10000;
  
        camera.dragging = false;
        camera.panning = false;
        camera.lastX = 0;
        camera.lastY = 0;
        return camera;
      }

      //-----------------------------------------------------------------------
      // Scene
      //-----------------------------------------------------------------------

      function createScene(camAspect) {
        const scene = {
          camera: createCamera(camAspect),
          lightSource: {
            position: [280.0, 280.0, 0.0],
            color: [1.0, 1.0, 1.0],
            lightViewMat: mat4Identity(),
            lightProjMat: mat4Perspective(
              Math.PI / 2.0,
              1.0,
              0.1,
              10000.0
            ),
          },
          //mesh: createCube(1.2),
          //mesh: createSphere(0.8, 32, 32),
          mesh: createCornellBox(),
          time: 0,
        };
        lookAt(scene.lightSource.lightViewMat, scene.lightSource.position, [280.0, 280.0, 280.0], [0, 1, 0]);
        return scene;
      }

      async function createGPUApp() {
        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }
        const GPUApp = {
          // Components used for setting up the graphics environment
          canvas: {},
          // Implementation of WebGPU
          adapter: {},
          // GPU interface to create objects on the GPU
          device: {},
          // Configures WebGPU
          context: {},
          canvasFormat: {},
          // GPU memory story the mesh data
          meshBuffers:{},
          // GPU memory used to pass parameters from CPU to GPU, such as the camera or light properties
          uniformBuffer: {},
          uniformBufferForShadow: {},
          // Handle on GPU parameters
          bindGroup: {},
          bindGroupForShadow: {},
          // Handle on the GPU shaders
          shaderModule: {},
          // Shadow code used for rendering
          shadowShaderModule: {},
          // Organization of the input of the pipeline/vertex shader
          vertexBuffersLayout: {},
          vertexBuffersLayoutForShadow: {},
          // Organization of the 
          bindGroupLayout: {},
          bindGroupLayoutForShadow: {},
          // Rasterization pipeline
          rasterizationPipeline: {},
          // Ray Tracing pipeline
          rayTracingPipeline: {},
          // Shadow pipeline
          shadowPipeline: {},
          // Depth map used to store per-pixel depth (Z-Buffer)
          depthTexture: {},
          // Shadow depth map
          shadowDepthTexture: {},
          // Model/View/Inverse View/Projection matrix (16 floats each), light position (3+1 pad floats), color (3+1 pad float), fov  (1+3 pad float), aspectRatio (1+3 pad fsloat)
          uniformData : new Float32Array(76),
          uniformDataForShadow : new Float32Array(16+16+4),
        };
        GPUApp.canvas = document.querySelector("canvas"),
        GPUApp.adapter = await navigator.gpu.requestAdapter();
        if (!GPUApp.adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }
        GPUApp.device = await GPUApp.adapter.requestDevice();
        GPUApp.context = GPUApp.canvas.getContext("webgpu");
        GPUApp.canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        GPUApp.context.configure({
          device: GPUApp.device,
          format: GPUApp.canvasFormat,
          alphaMode: "opaque",
        });
        return GPUApp;
      }

      function createGPUBuffer(device, data, usage) {
        const buffer = device.createBuffer({
          size: (data.byteLength + 3) & ~3, // 4-byte aligned
          usage
        });
        device.queue.writeBuffer(buffer, 0, data);
      
        return buffer;
      }

      function createMeshBuffers(GPUApp, mesh) {
        return {
          positionBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.positions,
            GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),
          
          normalBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.normals,
            GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),

          colorBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.colors,
            GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),
          
          uvBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.uvs,
            GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
          ),
          
          indexBuffer: createGPUBuffer(
            GPUApp.device,
            mesh.indices,
            GPUBufferUsage.INDEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          ),
          
          indexFormat: "uint32"
        };
      }

      function createVertexBuffersLayoutForShadow() {
        return [
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" } // position
            ]
          }
        ];
      }
      
      function createVertexBuffersLayout() {
        return [
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" } // position
            ]
          },
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 1, offset: 0, format: "float32x3" } // normal
            ]
          },
          {
            arrayStride: 3 * 4,
            attributes: [
              { shaderLocation: 2, offset: 0, format: "float32x3" } // color
            ]
          },
          {
            arrayStride: 2 * 4,
            attributes: [
              { shaderLocation: 3, offset: 0, format: "float32x2" } // uv
            ]
          }
        ];
      }

      // Create and fill the GPU buffers used to store the geometry to render
      function initGPUBuffers(GPUApp, scene) {

        GPUApp.meshBuffers = createMeshBuffers(GPUApp, scene.mesh);

        GPUApp.uniformBuffer = createGPUBuffer(
          GPUApp.device, 
          GPUApp.uniformData, 
          GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        );

        GPUApp.uniformBufferForShadow = createGPUBuffer(
          GPUApp.device, 
          GPUApp.uniformDataForShadow, 
          GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        );

        GPUApp.bindGroupForShadow = GPUApp.device.createBindGroup({
          layout: GPUApp.bindGroupLayoutForShadow,
          entries: [{
            binding: 0,
            resource: { buffer: GPUApp.uniformBuffer },
          }],
         });

        GPUApp.bindGroup = GPUApp.device.createBindGroup({
          layout: GPUApp.bindGroupLayout,
          entries: [{
            binding: 0,
            resource: { buffer: GPUApp.uniformBuffer },
          },
          {
            binding: 1,
            resource: { buffer: GPUApp.meshBuffers.positionBuffer },
          },
          {
            binding: 2,
            resource: { buffer: GPUApp.meshBuffers.normalBuffer },
          },
          {
            binding: 3,
            resource: { buffer: GPUApp.meshBuffers.colorBuffer },
          },
          {
            binding: 4,
            resource: { buffer: GPUApp.meshBuffers.indexBuffer },
          }],
         });
      }

      function initRenderPipeline(GPUApp) {
        const shaders = document.getElementById("shaders").textContent;
        const shadowShaders = document.getElementById("shadow-shaders").textContent;
        GPUApp.shaderModule = GPUApp.device.createShaderModule({
          label: "Shaders",
          code: shaders
        });
        GPUApp.shadowShaderModule = GPUApp.device.createShaderModule({
          label: "Shadow Shaders",
          code: shadowShaders
        });

        GPUApp.vertexBuffersLayoutForShadow = createVertexBuffersLayoutForShadow();
        GPUApp.vertexBuffersLayout = createVertexBuffersLayout();

        GPUApp.bindGroupLayoutForShadow = GPUApp.device.createBindGroupLayout({
          entries: [{
            binding: 0,
            visibility: GPUShaderStage.VERTEX,
            buffer: { type: "uniform" },
          }],
        });

        GPUApp.bindGroupLayout = GPUApp.device.createBindGroupLayout({
          entries: [{
            binding: 0,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "uniform" },
          },
          {
            binding: 1,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "read-only-storage" },
          },
          {
            binding: 2,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "read-only-storage" },
          },
          {
            binding: 3,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "read-only-storage" },
          },
          {
            binding: 4,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "read-only-storage" },
          }],
        });  

        GPUApp.rasterizationPipeline = GPUApp.device.createRenderPipeline({
            label: "rasterizationPipeline",
            //layout: "auto",
            layout: GPUApp.device.createPipelineLayout({
              bindGroupLayouts: [GPUApp.bindGroupLayout],
            }),
            vertex: {
              module: GPUApp.shaderModule,
              entryPoint: "rasterVertexMain",
              buffers: GPUApp.vertexBuffersLayout
            },
            fragment: {
              module: GPUApp.shaderModule,
              entryPoint: "rasterFragmentMain",
              targets: [{
                format: GPUApp.canvasFormat
              }]
            },
            primitive: {
              topology: "triangle-list", // use "line-list" for sanity check
              cullMode: "back", // activate backface culling
            },
            depthStencil: {
              format: "depth24plus",   // Must match depth texture
              depthWriteEnabled: true,
              depthCompare: "less",    // Standard depth (Z) test
          },
        });

        // Texture used for the Z-Buffer depth test
        GPUApp.depthTexture = GPUApp.device.createTexture({
          size: [GPUApp.canvas.width, GPUApp.canvas.height],
          format: "depth24plus",
          usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });

        // Texture used for the shadow map
        GPUApp.shadowDepthTexture = GPUApp.device.createTexture({
          size: [GPUApp.canvas.width, GPUApp.canvas.height],
          format: "depth24plus",
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
        });

        GPUApp.rayTracingPipeline = GPUApp.device.createRenderPipeline({
            label: "rayTracingPipeline",
            //layout: "auto",
            layout: GPUApp.device.createPipelineLayout({
              bindGroupLayouts: [GPUApp.bindGroupLayoutForShadow],
            }),
            vertex: {
              module: GPUApp.shaderModule,
              entryPoint: "rayVertexMain",
            },
            fragment: {
              module: GPUApp.shaderModule,
              entryPoint: "rayFragmentMain",
              targets: [{
                format: GPUApp.canvasFormat
              }]
            },
            primitive: {
              topology: "triangle-list", // use "line-list" for sanity check
              cullMode: "back", // activate backface culling
            },
            depthStencil: {
              format: "depth24plus",   // Must match depth texture
              depthWriteEnabled: true,
              depthCompare: "less",    // Standard depth (Z) test
          },
        });

        GPUApp.shadowPipeline = GPUApp.device.createRenderPipeline({
            label: "shadowPipeline",
            //layout: "auto",
            layout: GPUApp.device.createPipelineLayout({
              bindGroupLayouts: [GPUApp.bindGroupLayoutForShadow],
            }),
            vertex: {
              module: GPUApp.shadowShaderModule,
              entryPoint: "shadowVertexMain",
              buffers: GPUApp.vertexBuffersLayoutForShadow
            },
            primitive: {
              topology: "triangle-list", // use "line-list" for sanity check
              cullMode: "back", // activate backface culling
            },
            depthStencil: {
              format: "depth24plus",   // Must match depth texture
              depthWriteEnabled: true,
              depthCompare: "less",    // Standard depth (Z) test
          },
        });
      }

      function initEvents (GPUApp, scene) {
        GPUApp.canvas.addEventListener("mousedown", e => {
          scene.camera.lastX = e.clientX;
          scene.camera.lastY = e.clientY;

          if (e.button === 0) scene.camera.dragging = true;   // left = rotate
          if (e.button === 1 || e.button === 2) scene.camera.panning = true; // middle/right = pan
        });

        window.addEventListener("mouseup", () => {
          scene.camera.dragging = false;
          scene.camera.panning = false;
        });

        GPUApp.canvas.addEventListener("mousemove", e => {
          const dx = e.clientX - scene.camera.lastX;
          const dy = e.clientY - scene.camera.lastY;
          scene.camera.lastX = e.clientX;
          scene.camera.lastY = e.clientY;

          if (scene.camera.dragging) {
            scene.camera.yaw   -= dx * scene.camera.rotateSpeed;
            scene.camera.pitch += dy * scene.camera.rotateSpeed;

            const maxPitch = Math.PI / 2 - 0.01;
            scene.camera.pitch = Math.max(-maxPitch, Math.min(maxPitch, scene.camera.pitch));
          }

          if (scene.camera.panning) {
            pan(scene.camera, dx, -dy);
          }
        });

        GPUApp.canvas.addEventListener("wheel", e => {
          e.preventDefault();
          scene.camera.radius *= 1 + e.deltaY * scene.camera.zoomSpeed;
          scene.camera.radius = Math.max(scene.camera.minRadius, Math.min(scene.camera.maxRadius, scene.camera.radius));
        }, { passive: false });

        GPUApp.canvas.addEventListener("contextmenu", e => e.preventDefault());
      }

      function animate(scene) {
        scene.time += 1.0;
        const angle = scene.time/40.0;
        scene.lightSource.position = [200.0*Math.cos (angle) + 280, 500, 200.0*Math.sin (angle) + 280];
        lookAt(scene.lightSource.lightViewMat, scene.lightSource.position, scene.camera.target, scene.camera.up);
      }

      function updateUniforms(GPUApp, scene) {
        updateCamera(scene.camera);
        GPUApp.uniformData.set(scene.camera.modelMat, 0);
        GPUApp.uniformData.set(scene.camera.viewMat, 16);
        const invViewMat = mat4Invert (scene.camera.viewMat);
        GPUApp.uniformData.set(invViewMat, 32);
        GPUApp.uniformData.set(scene.camera.projMat, 48);
        GPUApp.uniformData.set(scene.lightSource.position, 64);
        var useRaytracedShadows = document.getElementById("raytracedShadowsCheckbox").checked;
        GPUApp.uniformData[67] = (useRaytracedShadows == true ? 1 : 0); // Ray traced shadow
        GPUApp.uniformData.set(scene.lightSource.color, 68);
        GPUApp.uniformData[72] = scene.camera.fov;
        GPUApp.uniformData[73] = scene.camera.aspect;
        GPUApp.device.queue.writeBuffer(
          GPUApp.uniformBuffer,
          0,
          GPUApp.uniformData.buffer,
          GPUApp.uniformData.byteOffset,
          GPUApp.uniformData.byteLength
        );
      }

      function updateUniformsForShadow(GPUApp, scene) {
        let depthMVP = mat4Multiply(scene.lightSource.lightProjMat, scene.lightSource.lightViewMat);
        GPUApp.uniformDataForShadow.set(depthMVP, 0);
        GPUApp.uniformDataForShadow.set(scene.camera.modelMat, 16);
        GPUApp.device.queue.writeBuffer(
          GPUApp.uniformBufferForShadow,
          0,
          GPUApp.uniformDataForShadow.buffer,
          GPUApp.uniformDataForShadow.byteOffset,
          GPUApp.uniformDataForShadow.byteLength
        );
      }

      function render(GPUApp, scene) {
        var useRayTracing = document.getElementById("raytracingCheckbox").checked;
        if (document.getElementById("animateCheckbox").checked)
          animate(scene);
        updateUniforms(GPUApp, scene);
        updateUniformsForShadow(GPUApp, scene);
        const encoder = GPUApp.device.createCommandEncoder();
        const shadowPass = encoder.beginRenderPass({
          label: "Shadow map generation pass",
          colorAttachments: [],
          depthStencilAttachment: {
            view: GPUApp.shadowDepthTexture.createView(),
            depthClearValue: 1.0,
            depthLoadOp: "clear",
            depthStoreOp: "store",
          },
        });
        shadowPass.setPipeline(GPUApp.shadowPipeline);
        shadowPass.setBindGroup(0, GPUApp.bindGroupForShadow);
        shadowPass.setVertexBuffer(0, GPUApp.meshBuffers.positionBuffer);
        shadowPass.setIndexBuffer(GPUApp.meshBuffers.indexBuffer, GPUApp.meshBuffers.indexFormat);
        shadowPass.drawIndexed(scene.mesh.indices.length);
        shadowPass.end();

        const renderPass = encoder.beginRenderPass({
          label: "Main rendering pass",
          colorAttachments: [{
            view: GPUApp.context.getCurrentTexture().createView(),
            loadOp: "clear",
            clearValue: { r: 0, g: 0, b: 0, a: 1 },
            storeOp: "store",
          }],
          sampleCount: 1,
          depthStencilAttachment: {
            view: GPUApp.depthTexture.createView(),
            depthClearValue: 1.0,
            depthLoadOp: "clear",
            depthStoreOp: "store",
          },
        });
        if (useRayTracing == true)
          renderPass.setPipeline(GPUApp.rayTracingPipeline);
        else {
          
          renderPass.setPipeline(GPUApp.rasterizationPipeline);
        }
        renderPass.setBindGroup(0, GPUApp.bindGroup);
        if (useRayTracing == false) {
          renderPass.setVertexBuffer(0, GPUApp.meshBuffers.positionBuffer);
          renderPass.setVertexBuffer(1, GPUApp.meshBuffers.normalBuffer);
          renderPass.setVertexBuffer(2, GPUApp.meshBuffers.colorBuffer);
          renderPass.setVertexBuffer(3, GPUApp.meshBuffers.uvBuffer);
          renderPass.setIndexBuffer(GPUApp.meshBuffers.indexBuffer, GPUApp.meshBuffers.indexFormat);
          renderPass.drawIndexed(scene.mesh.indices.length);
        } else {
          renderPass.draw(6); // 2 triangles for a full screen quad
        }
        renderPass.end();
        const commandBuffer = encoder.finish();
        GPUApp.device.queue.submit([commandBuffer]);
      }

      async function main() {
        const GPUApp = await createGPUApp();
        const camAspect = GPUApp.canvas.width/GPUApp.canvas.height;
        initRenderPipeline(GPUApp);
        const scene = createScene(camAspect);
        initEvents (GPUApp, scene);
        initGPUBuffers(GPUApp, scene);
        // Animate at 60Hz
        setInterval(function() { render(GPUApp, scene); }, 16.6);
      }

      main();

    </script>
  </body>
</html>